(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("xgplayer"));
	else if(typeof define === 'function' && define.amd)
		define(["xgplayer"], factory);
	else if(typeof exports === 'object')
		exports["xgplayer-flv"] = factory(require("xgplayer"));
	else
		root["xgplayer-flv"] = factory(root["xgplayer"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_xgplayer__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/events/events.js":
/*!****************************************************************************!*\
  !*** /Users/leonardo/toutiao/temai/xgplayer/node_modules/events/events.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function (n) {\n  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function (type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events) this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler)) return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++) listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function (type, listener) {\n  var m;\n\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function (type, listener) {\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function (type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type]) return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener || isFunction(list.listener) && list.listener === listener) {\n    delete this._events[type];\n    if (this._events.removeListener) this.emit('removeListener', type, listener);\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener) this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function (type) {\n  var key, listeners;\n\n  if (!this._events) return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function (type) {\n  var ret;\n  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function (type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n//# sourceURL=webpack://xgplayer-flv//Users/leonardo/toutiao/temai/xgplayer/node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/concat-typed-array/lib/concat.js":
/*!*******************************************************!*\
  !*** ./node_modules/concat-typed-array/lib/concat.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (ResultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = arrays[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arr = _step.value;\n\n      totalLength += arr.length;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var result = new ResultConstructor(totalLength);\n  var offset = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = arrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _arr = _step2.value;\n\n      result.set(_arr, offset);\n      offset += _arr.length;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/concat-typed-array/lib/concat.js?");

/***/ }),

/***/ "./node_modules/concat-typed-array/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/concat-typed-array/lib/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _concat = __webpack_require__(/*! ./concat */ \"./node_modules/concat-typed-array/lib/concat.js\");\n\nvar _concat2 = _interopRequireDefault(_concat);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nmodule.exports = _concat2.default;\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/concat-typed-array/lib/index.js?");

/***/ }),

/***/ "./node_modules/d/index.js":
/*!*********************************!*\
  !*** ./node_modules/d/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assign = __webpack_require__(/*! es5-ext/object/assign */ \"./node_modules/es5-ext/object/assign/index.js\"),\n    normalizeOpts = __webpack_require__(/*! es5-ext/object/normalize-options */ \"./node_modules/es5-ext/object/normalize-options.js\"),\n    isCallable = __webpack_require__(/*! es5-ext/object/is-callable */ \"./node_modules/es5-ext/object/is-callable.js\"),\n    contains = __webpack_require__(/*! es5-ext/string/#/contains */ \"./node_modules/es5-ext/string/#/contains/index.js\"),\n    d;\n\nd = module.exports = function (dscr, value /*, options*/) {\n\tvar c, e, w, options, desc;\n\tif (arguments.length < 2 || typeof dscr !== 'string') {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set /*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/d/index.js?");

/***/ }),

/***/ "./node_modules/es5-ext/function/noop.js":
/*!***********************************************!*\
  !*** ./node_modules/es5-ext/function/noop.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// eslint-disable-next-line no-empty-function\n\nmodule.exports = function () {};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/function/noop.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/assign/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/es5-ext/object/assign/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./is-implemented */ \"./node_modules/es5-ext/object/assign/is-implemented.js\")() ? Object.assign : __webpack_require__(/*! ./shim */ \"./node_modules/es5-ext/object/assign/shim.js\");\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/assign/index.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/assign/is-implemented.js":
/*!**************************************************************!*\
  !*** ./node_modules/es5-ext/object/assign/is-implemented.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function () {\n\tvar assign = Object.assign,\n\t    obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/assign/is-implemented.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/assign/shim.js":
/*!****************************************************!*\
  !*** ./node_modules/es5-ext/object/assign/shim.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! ../keys */ \"./node_modules/es5-ext/object/keys/index.js\"),\n    value = __webpack_require__(/*! ../valid-value */ \"./node_modules/es5-ext/object/valid-value.js\"),\n    max = Math.max;\n\nmodule.exports = function (dest, src /*, …srcn*/) {\n\tvar error,\n\t    i,\n\t    length = max(arguments.length, 2),\n\t    assign;\n\tdest = Object(value(dest));\n\tassign = function assign(key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/assign/shim.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/is-callable.js":
/*!****************************************************!*\
  !*** ./node_modules/es5-ext/object/is-callable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Deprecated\n\n\n\nmodule.exports = function (obj) {\n  return typeof obj === \"function\";\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/is-callable.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/is-value.js":
/*!*************************************************!*\
  !*** ./node_modules/es5-ext/object/is-value.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _undefined = __webpack_require__(/*! ../function/noop */ \"./node_modules/es5-ext/function/noop.js\")(); // Support ES3 engines\n\nmodule.exports = function (val) {\n  return val !== _undefined && val !== null;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/is-value.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/keys/index.js":
/*!***************************************************!*\
  !*** ./node_modules/es5-ext/object/keys/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./is-implemented */ \"./node_modules/es5-ext/object/keys/is-implemented.js\")() ? Object.keys : __webpack_require__(/*! ./shim */ \"./node_modules/es5-ext/object/keys/shim.js\");\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/keys/index.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/keys/is-implemented.js":
/*!************************************************************!*\
  !*** ./node_modules/es5-ext/object/keys/is-implemented.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/keys/is-implemented.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/keys/shim.js":
/*!**************************************************!*\
  !*** ./node_modules/es5-ext/object/keys/shim.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isValue = __webpack_require__(/*! ../is-value */ \"./node_modules/es5-ext/object/is-value.js\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n  return keys(isValue(object) ? Object(object) : object);\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/keys/shim.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/normalize-options.js":
/*!**********************************************************!*\
  !*** ./node_modules/es5-ext/object/normalize-options.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isValue = __webpack_require__(/*! ./is-value */ \"./node_modules/es5-ext/object/is-value.js\");\n\nvar forEach = Array.prototype.forEach,\n    create = Object.create;\n\nvar process = function process(src, obj) {\n\tvar key;\n\tfor (key in src) {\n\t\tobj[key] = src[key];\n\t}\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1 /*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/normalize-options.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/valid-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/es5-ext/object/valid-callable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/valid-callable.js?");

/***/ }),

/***/ "./node_modules/es5-ext/object/valid-value.js":
/*!****************************************************!*\
  !*** ./node_modules/es5-ext/object/valid-value.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isValue = __webpack_require__(/*! ./is-value */ \"./node_modules/es5-ext/object/is-value.js\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/object/valid-value.js?");

/***/ }),

/***/ "./node_modules/es5-ext/string/#/contains/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/es5-ext/string/#/contains/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./is-implemented */ \"./node_modules/es5-ext/string/#/contains/is-implemented.js\")() ? String.prototype.contains : __webpack_require__(/*! ./shim */ \"./node_modules/es5-ext/string/#/contains/shim.js\");\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/string/#/contains/index.js?");

/***/ }),

/***/ "./node_modules/es5-ext/string/#/contains/is-implemented.js":
/*!******************************************************************!*\
  !*** ./node_modules/es5-ext/string/#/contains/is-implemented.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/string/#/contains/is-implemented.js?");

/***/ }),

/***/ "./node_modules/es5-ext/string/#/contains/shim.js":
/*!********************************************************!*\
  !*** ./node_modules/es5-ext/string/#/contains/shim.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString /*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/es5-ext/string/#/contains/shim.js?");

/***/ }),

/***/ "./node_modules/event-emitter/index.js":
/*!*********************************************!*\
  !*** ./node_modules/event-emitter/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar d = __webpack_require__(/*! d */ \"./node_modules/d/index.js\"),\n    callable = __webpack_require__(/*! es5-ext/object/valid-callable */ \"./node_modules/es5-ext/object/valid-callable.js\"),\n    apply = Function.prototype.apply,\n    call = Function.prototype.call,\n    create = Object.create,\n    defineProperty = Object.defineProperty,\n    defineProperties = Object.defineProperties,\n    hasOwnProperty = Object.prototype.hasOwnProperty,\n    descriptor = { configurable: true, enumerable: false, writable: true },\n    on,\n    _once2,\n    off,\n    emit,\n    methods,\n    descriptors,\n    base;\n\non = function on(type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;else if (_typeof(data[type]) === 'object') data[type].push(listener);else data[type] = [data[type], listener];\n\n\treturn this;\n};\n\n_once2 = function once(type, listener) {\n\tvar _once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, _once = function once() {\n\t\toff.call(self, type, _once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\t_once.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function off(type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === 'object') {\n\t\tfor (i = 0; candidate = listeners[i]; ++i) {\n\t\t\tif (candidate === listener || candidate.__eeOnceListener__ === listener) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];else listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (listeners === listener || listeners.__eeOnceListener__ === listener) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function emit(type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) {\n\t\t\targs[i - 1] = arguments[i];\n\t\t}listeners = listeners.slice();\n\t\tfor (i = 0; listener = listeners[i]; ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tcall.call(listeners, this);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tl = arguments.length;\n\t\t\t\targs = new Array(l - 1);\n\t\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t\t}\n\t\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: _once2,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(_once2),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function exports(o) {\n\treturn o == null ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n\n//# sourceURL=webpack://xgplayer-flv/./node_modules/event-emitter/index.js?");

/***/ }),

/***/ "./src/Flv.js":
/*!********************!*\
  !*** ./src/Flv.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author fuyuhao\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _MainParser = __webpack_require__(/*! ./parse/MainParser */ \"./src/parse/MainParser.js\");\n\nvar _MainParser2 = _interopRequireDefault(_MainParser);\n\nvar _MSE = __webpack_require__(/*! ./parse/MSE */ \"./src/parse/MSE.js\");\n\nvar _MSE2 = _interopRequireDefault(_MSE);\n\nvar _VodTask = __webpack_require__(/*! ./tasks/VodTask */ \"./src/tasks/VodTask.js\");\n\nvar _VodTask2 = _interopRequireDefault(_VodTask);\n\nvar _config = __webpack_require__(/*! ./constants/config */ \"./src/constants/config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable no-unused-vars */\nvar Flv = function () {\n  function Flv(options, player) {\n    _classCallCheck(this, Flv);\n\n    this._player = player;\n    this._options = Object.assign({}, (0, _config2.default)(), options);\n    this.flvPlayer = new _MainParser2.default(this._options, player);\n    this.mse = new _MSE2.default();\n    this.isSeeking = false;\n    this.isDataLoading = false;\n    this.tempCurrentTime = 0;\n    this.tempFlvPlayer = null;\n    this.initPlayerEvents(player, this._options);\n    this.initFlvPlayerEvents(this.flvPlayer, this.mse);\n    this.initMseEvents(this.mse, this.flvPlayer);\n  }\n\n  _createClass(Flv, [{\n    key: 'load',\n    value: function load() {\n      this.flvPlayer.startLoadData();\n    }\n  }, {\n    key: 'initPlayerEvents',\n    value: function initPlayerEvents(player, options) {\n      var _this = this;\n\n      var mse = this.mse;\n\n      player.mse = mse;\n      if (!options.isLive) {\n        player.on('seeking', function () {\n          var buffered = player.buffered,\n              currentTime = player.currentTime;\n\n          var isBuffered = false;\n          if (buffered.length) {\n            for (var i = 0, len = buffered.length; i < len; i++) {\n              if (currentTime > buffered.start(i) && currentTime < buffered.end(i)) {\n                isBuffered = true;\n                break;\n              }\n            }\n          }\n          if (isBuffered) {\n            return;\n          }\n          _VodTask2.default.clear();\n          if (!_this.isSeekable) {\n            _this._player.currentTime = _this.tempCurrentTime;\n            return;\n          }\n          _this.flvPlayer.seek(player.currentTime);\n          _this.isSeeking = true;\n        });\n      }\n      player.on('timeupdate', function () {\n        _this.tempCurrentTime = player.currentTime;\n        if (!_this.isSeeking && _this.flvPlayer.isMediaInfoReady && !_this.tempFlvPlayer) {\n          _this.progressChecker(player);\n        }\n        _this.isEnded(player, _this.flvPlayer);\n      });\n      player._replay = function () {\n        player.mse.destroy();\n        _VodTask2.default.clear();\n        var _mse = new _MSE2.default();\n        _this.flvPlayer.replay();\n\n        mse.on('sourceopen', function () {\n          _this.flvPlayer.isSourceOpen = true;\n          mse.appendBuffer(_this.flvPlayer.ftyp_moov.buffer);\n          mse.on('updateend', function () {\n            var _flvPlayer = _this.flvPlayer,\n                pendingFragments = _flvPlayer.pendingFragments,\n                hasPendingFragments = _flvPlayer.hasPendingFragments;\n\n            _this.isSeeking = false;\n            if (hasPendingFragments) {\n              var fragment = pendingFragments.shift();\n              console.log(fragment);\n              if (!mse.appendBuffer(fragment.data)) {\n                pendingFragments.unshift(fragment);\n              } else {\n                player.emit('cacheupdate', player);\n              }\n            }\n          });\n        });\n        mse.on('error', function (e) {\n          player.emit('error', e);\n        });\n\n        player.mse = mse;\n        player.src = _this.mse.url;\n        return true;\n      };\n      player.switchURL = function (url) {\n        _this._options.url = url;\n        _this.flvPlayer.unbindEvents();\n        _VodTask2.default.clear();\n        if (!player.config.isLive) {\n          var tempFlvPlayer = _this.tempFlvPlayer = new _MainParser2.default(_this._options, player);\n\n          tempFlvPlayer.isSourceOpen = true;\n          tempFlvPlayer.isTempPlayer = true;\n          _this.initFlvPlayerEvents(tempFlvPlayer, mse);\n          tempFlvPlayer.handleMediaFragment = function () {\n            _this.isSeeking = false;\n            _this.unbindFlvPlayerEvents(_this.flvPlayer);\n            _this.flvPlayer.destroy();\n            _this.flvPlayer = tempFlvPlayer;\n            _this.tempFlvPlayer = null;\n\n            mse.appendBuffer(tempFlvPlayer.ftyp_moov);\n            tempFlvPlayer.handleMediaFragment = function (fragment) {\n              return mse.appendBuffer(fragment.data);\n            };\n            return false;\n          };\n          tempFlvPlayer.startLoadData();\n        }\n      };\n    }\n  }, {\n    key: 'unbindFlvPlayerEvents',\n    value: function unbindFlvPlayerEvents(flvPlayer) {\n      flvPlayer.handleSeekEnd = function () {\n        return null;\n      };\n      flvPlayer.handleError = function () {\n        return null;\n      };\n      flvPlayer.handleMediaFragment = function () {\n        return null;\n      };\n    }\n  }, {\n    key: 'initFlvPlayerEvents',\n    value: function initFlvPlayerEvents(flvPlayer, mse) {\n      var _this2 = this;\n\n      var handleFtypMoov = function handleFtypMoov(ftypMoov) {\n        if (flvPlayer.isSourceOpen && !_this2.tempFlvPlayer) {\n          mse.appendBuffer(ftypMoov.buffer);\n        } else {\n          _this2.isSeeking = true;\n          flvPlayer.seek(_this2._player.currentTime);\n        }\n      };\n      flvPlayer.once('ready', handleFtypMoov);\n      flvPlayer.handleSeekEnd = function () {\n        _this2.isSeeking = false;\n      };\n      flvPlayer.handleError = function (e) {\n        this._player.emit('error', e);\n      };\n      if (!this.tempFlvPlayer) {\n        flvPlayer.handleMediaFragment = function (fragment) {\n          return _this2.tempFlvPlayer ? false : mse.appendBuffer(fragment.data);\n        };\n      }\n    }\n  }, {\n    key: 'initMseEvents',\n    value: function initMseEvents(mse) {\n      var _this3 = this;\n\n      mse.on('error', function (e) {\n        _this3._player.emit('error', e);\n      });\n      var onSourceOpen = function onSourceOpen() {\n        _this3.flvPlayer.isSourceOpen = true;\n        if (_this3.flvPlayer.ftyp_moov !== null) {\n          mse.appendBuffer(_this3.flvPlayer.ftyp_moov.buffer);\n        }\n\n        mse.on('updateend', function () {\n          var _flvPlayer2 = _this3.flvPlayer,\n              pendingFragments = _flvPlayer2.pendingFragments,\n              hasPendingFragments = _flvPlayer2.hasPendingFragments;\n\n\n          if (hasPendingFragments) {\n            var fragment = pendingFragments.shift();\n            if (!mse.appendBuffer(fragment.data)) {\n              pendingFragments.unshift(fragment);\n            } else {\n              console.log(fragment);\n              _this3._player.emit('cacheupdate', _this3._player);\n            }\n          }\n        });\n      };\n      mse.on('sourceopen', onSourceOpen);\n    }\n  }, {\n    key: 'loadData',\n    value: function loadData(currentTime) {\n      return this.flvPlayer.loadSegments(true, currentTime, this._options.preloadTime);\n    }\n  }, {\n    key: 'progressChecker',\n    value: function progressChecker(player) {\n      var _this4 = this;\n\n      var _options = this._options,\n          minCachedTime = _options.minCachedTime,\n          preloadTime = _options.preloadTime;\n\n      var range = player.getBufferedRange();\n      if (this.flvPlayer.videoDuration - range[1] * this.flvPlayer.videoTimeScale < 0.1 * this.flvPlayer.videoTimeScale) {\n        return;\n      }\n      if (range[1] - player.currentTime < minCachedTime && !this.isDataLoading) {\n        this.isDataLoading = true;\n        this.flvPlayer.loadSegments(true, player.currentTime, preloadTime).then(function () {\n          _this4.isDataLoading = false;\n        });\n      }\n    }\n  }, {\n    key: 'isEnded',\n    value: function isEnded(player, flv) {\n      if (flv.videoDuration - player.currentTime * flv.videoTimeScale < 2 * flv.videoTimeScale) {\n        var range = player.getBufferedRange();\n        if (player.currentTime - range[1] < 0.1) {\n          this.mse.endOfStream();\n        }\n      }\n    }\n  }, {\n    key: 'isSeekable',\n    get: function get() {\n      return this.flvPlayer.isSeekable;\n    }\n  }]);\n\n  return Flv;\n}();\n\nexports.default = Flv;\n\n//# sourceURL=webpack://xgplayer-flv/./src/Flv.js?");

/***/ }),

/***/ "./src/constants/config.js":
/*!*********************************!*\
  !*** ./src/constants/config.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar getDefaultConf = function getDefaultConf() {\n  return {\n    preloadTime: 30,\n    minCachedTime: 5,\n    autoCleanSourceBuffer: true,\n    autoCleanMaxBackTime: 30,\n    isLive: false,\n    cors: true\n  };\n};\n\nexports.default = getDefaultConf;\n\n//# sourceURL=webpack://xgplayer-flv/./src/constants/config.js?");

/***/ }),

/***/ "./src/constants/metaFields.js":
/*!*************************************!*\
  !*** ./src/constants/metaFields.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar fields = [{\n  name: 'duration',\n  type: Boolean,\n  parser: function parser(target, origin) {\n    target.mediaInfo.duration = origin.duration;\n  }\n}, {\n  name: 'hasAudio',\n  type: Boolean,\n  parser: function parser(target, origin) {\n    target.mediaInfo.hasAudio = origin.hasAudio;\n  }\n}, {\n  name: 'hasVideo',\n  type: Boolean,\n  parser: function parser(target, origin) {\n    target.mediaInfo.hasVideo = origin.hasVideo;\n  }\n}, {\n  name: 'audiodatarate',\n  type: Number,\n  parser: function parser(target, origin) {\n    target.mediaInfo.audioDataRate = origin.audiodatarate;\n  }\n}, {\n  name: 'videodatarate',\n  type: Number,\n  parser: function parser(target, origin) {\n    target.mediaInfo.videoDataRate = origin.videodatarate;\n  }\n}, {\n  name: 'width',\n  type: Number,\n  parser: function parser(target, origin) {\n    target.mediaInfo.width = origin.width;\n  }\n}, {\n  name: 'height',\n  type: Number,\n  parser: function parser(target, origin) {\n    target.mediaInfo.height = origin.height;\n  }\n}, {\n  name: 'duration',\n  type: Number,\n  parser: function parser(target, origin) {\n    if (!target.state.duration) {\n      var duration = Math.floor(origin.duration * target.state.timeScale);\n      target.state.duration = target.mediaInfo.duration = duration;\n    }\n  },\n  onTypeErr: function onTypeErr(target) {\n    target.mediaInfo.duration = 0;\n  }\n}, {\n  name: 'framerate',\n  type: Number,\n  parser: function parser(target, origin) {\n    var fpsNum = Math.floor(origin.framerate * 1000);\n    if (fpsNum > 0) {\n      var fps = fpsNum / 1000;\n      var referFrameRate = target.referFrameRate,\n          mediaInfo = target.mediaInfo;\n\n      referFrameRate.fixed = true;\n      referFrameRate.fps = fps;\n      referFrameRate.fpsNum = fpsNum;\n      referFrameRate.fpsDen = 1000;\n      mediaInfo.fps = fps;\n    }\n  }\n}, {\n  name: 'keyframes',\n  type: Object,\n  parser: function parser(target, origin) {\n    var keyframes = origin.keyframes;\n\n    target.mediaInfo.hasKeyframes = !!keyframes;\n    if (keyframes) {\n      target.mediaInfo.keyframes = this._parseKeyframes(keyframes);\n    }\n    origin.keyframes = null;\n  },\n  onTypeErr: function onTypeErr(target) {\n    target.mediaInfo.hasKeyframes = false;\n  }\n}];\nexports.default = fields;\n\n//# sourceURL=webpack://xgplayer-flv/./src/constants/metaFields.js?");

/***/ }),

/***/ "./src/constants/types.js":
/*!********************************!*\
  !*** ./src/constants/types.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MetaTypes = exports.MetaTypes = {\n  NUMBER: 0,\n  BOOLEAN: 1,\n  STRING: 2,\n  OBJECT: 3,\n  MIX_ARRAY: 8,\n  OBJECT_END: 9,\n  STRICT_ARRAY: 10,\n  DATE: 11,\n  LONE_STRING: 12\n};\n\nvar EventTypes = exports.EventTypes = {\n  DATA_READY: 'data_ready',\n  META_DATA_READY: 'meta_data_ready',\n  TRACK_META_READY: 'track_meta_ready',\n  MEDIA_INFO_READY: 'media_info_ready',\n  META_END_POSITION: 'meta_end_position',\n  ERROR: 'error'\n};\n\nvar soundRateTypes = exports.soundRateTypes = [5500, 11000, 22000, 4400];\n\nvar AudioObjectTypes = exports.AudioObjectTypes = {\n  0: 'Null',\n  1: 'AAC Main',\n  2: 'AAC LC',\n  3: 'AAC SSR(Scalable Sample Rate)',\n  4: 'AAC LTP(Long Term Prediction)',\n  5: 'HE-AAC / SBR(Spectral Band Replication)',\n  6: 'AAC Scalable'\n};\n\nvar samplingFrequencyTypes = exports.samplingFrequencyTypes = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000];\n\nvar browserTypes = exports.browserTypes = {\n  IE: 'ie',\n  FIRE_FOX: 'firefox',\n  CHROME: 'chrome',\n  OPERA: 'opera',\n  SAFARI: 'safari'\n};\n\nvar mp3Versions = exports.mp3Versions = {\n  V25: 0,\n  RESERVED: 1,\n  V20: 2,\n  V10: 3\n};\n\nvar audioSampleRate = exports.audioSampleRate = {\n  V10: [44100, 48000, 32000, 0],\n  V20: [22050, 24000, 16000, 0],\n  V25: [11025, 12000, 8000, 0]\n};\n\nvar mp3BitRate = exports.mp3BitRate = {\n  Layer1: [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1],\n  Layer2: [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1],\n  Layer3: [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1]\n};\n\n//# sourceURL=webpack://xgplayer-flv/./src/constants/types.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nvar _VodTask = __webpack_require__(/*! ./tasks/VodTask */ \"./src/tasks/VodTask.js\");\n\nvar _VodTask2 = _interopRequireDefault(_VodTask);\n\nvar _Flv = __webpack_require__(/*! ./Flv */ \"./src/Flv.js\");\n\nvar _Flv2 = _interopRequireDefault(_Flv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FlvPlayer = function (_Player) {\n  _inherits(FlvPlayer, _Player);\n\n  function FlvPlayer(options) {\n    _classCallCheck(this, FlvPlayer);\n\n    var _this = _possibleConstructorReturn(this, (FlvPlayer.__proto__ || Object.getPrototypeOf(FlvPlayer)).call(this, options));\n\n    _this._options = options;\n    _this.__flv__ = null;\n    _this.init(options);\n    return _this;\n  }\n\n  _createClass(FlvPlayer, [{\n    key: 'init',\n    value: function init(options) {\n      var player = this;\n      var isLive = options.isLive;\n\n      player.__flv__ = new _Flv2.default(options, player);\n      player.once('complete', function () {\n        player.createInstance(player.__flv__);\n      });\n      player.on('pause', function () {\n        !isLive && _VodTask2.default.clear();\n      });\n    }\n  }, {\n    key: 'createInstance',\n    value: function createInstance(flv) {\n      var player = this;\n      if (this._options.isLive) {\n        player.util.addClass(player.root, 'xgplayer-is-live');\n        var live = player.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');\n        player.controls.appendChild(live);\n      }\n      flv.load();\n    }\n  }, {\n    key: 'start',\n    value: function start() {\n      var __flv__ = this.__flv__;\n\n      _get(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'start', this).call(this, __flv__.mse.url);\n      this.src = __flv__.mse.url;\n      return true;\n    }\n  }]);\n\n  return FlvPlayer;\n}(_xgplayer2.default);\n\nmodule.exports = FlvPlayer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/index.js?");

/***/ }),

/***/ "./src/models/MediaInfo.js":
/*!*********************************!*\
  !*** ./src/models/MediaInfo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MediaInfo = function () {\n    function MediaInfo(data) {\n        var _this = this;\n\n        _classCallCheck(this, MediaInfo);\n\n        var _default = {\n            mimeType: null,\n            codec: '',\n            duration: null,\n            hasAudio: false,\n            hasVideo: false,\n            audioCodec: null,\n            videoCodec: null,\n\n            videoDataRate: null,\n            audioDataRate: null,\n            audioSampleRate: null,\n            audioChannelCount: null,\n            audioConfig: null,\n\n            width: null,\n            height: null,\n            fps: null,\n            profile: null,\n            level: null,\n            chromaFormat: null,\n\n            pixelRatio: [],\n\n            _metaData: null,\n            segments: [],\n            hasKeyframes: null,\n            keyframes: []\n        };\n\n        var initData = Object.assign({}, _default, data);\n        Object.entries(initData).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                k = _ref2[0],\n                v = _ref2[1];\n\n            _this[k] = v;\n        });\n    }\n\n    _createClass(MediaInfo, [{\n        key: 'isComplete',\n        get: function get() {\n            var mimeType = this.mimeType,\n                duration = this.duration,\n                hasKeyframes = this.hasKeyframes;\n\n            return mimeType !== null && duration !== null && hasKeyframes !== null && this.isVideoInfoFilled && this.isAudioInfoFilled;\n        }\n    }, {\n        key: 'isAudioInfoFilled',\n        get: function get() {\n            var hasAudio = this.hasAudio,\n                audioCodec = this.audioCodec,\n                audioSampleRate = this.audioSampleRate,\n                audioChannelCount = this.audioChannelCount;\n\n\n            return !!(!hasAudio || hasAudio && audioCodec && audioSampleRate && audioChannelCount);\n        }\n    }, {\n        key: 'isVideoInfoFilled',\n        get: function get() {\n            var notNullFields = ['videoCodec', 'width', 'height', 'fps', 'profile', 'level', 'chromaFormat'];\n            for (var i = 0, len = notNullFields.length; i < len; i++) {\n                if (this[notNullFields[i]] === null) {\n                    return false;\n                }\n            }\n\n            return this.hasVideo;\n        }\n    }]);\n\n    return MediaInfo;\n}();\n\nexports.default = MediaInfo;\n\n//# sourceURL=webpack://xgplayer-flv/./src/models/MediaInfo.js?");

/***/ }),

/***/ "./src/models/MediaSample.js":
/*!***********************************!*\
  !*** ./src/models/MediaSample.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MediaSample = function () {\n    function MediaSample(info) {\n        var _this = this;\n\n        _classCallCheck(this, MediaSample);\n\n        var _default = MediaSample.getDefaultInf();\n\n        if (!info || Object.prototype.toString.call(info) !== '[object Object]') {\n            return _default;\n        }\n        var sample = Object.assign({}, _default, info);\n\n        Object.entries(sample).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                k = _ref2[0],\n                v = _ref2[1];\n\n            _this[k] = v;\n        });\n    }\n\n    _createClass(MediaSample, null, [{\n        key: 'getDefaultInf',\n        value: function getDefaultInf() {\n            return {\n                dts: null,\n                pts: null,\n                duration: null,\n                position: null,\n                isRAP: false, // is Random access point\n                originDts: null\n            };\n        }\n    }]);\n\n    return MediaSample;\n}();\n\nexports.default = MediaSample;\n\n//# sourceURL=webpack://xgplayer-flv/./src/models/MediaSample.js?");

/***/ }),

/***/ "./src/models/MediaSegment.js":
/*!************************************!*\
  !*** ./src/models/MediaSegment.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MediaSegment = function () {\n    function MediaSegment() {\n        _classCallCheck(this, MediaSegment);\n\n        this.startDts = -1;\n        this.endDts = -1;\n        this.startPts = -1;\n        this.endPts = -1;\n        this.originStartDts = -1;\n        this.originEndDts = -1;\n        this.randomAccessPoints = [];\n        this.firstSample = null;\n        this.lastSample = null;\n    }\n\n    _createClass(MediaSegment, [{\n        key: \"addRAP\",\n        value: function addRAP(sample) {\n            sample.isRAP = true;\n            this.randomAccessPoints.push(sample);\n        }\n    }]);\n\n    return MediaSegment;\n}();\n\nexports.default = MediaSegment;\n\n//# sourceURL=webpack://xgplayer-flv/./src/models/MediaSegment.js?");

/***/ }),

/***/ "./src/models/MediaSegmentList.js":
/*!****************************************!*\
  !*** ./src/models/MediaSegmentList.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MediaSegmentList = function () {\n    function MediaSegmentList(type) {\n        _classCallCheck(this, MediaSegmentList);\n\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1; // cached last insert location\n    }\n\n    _createClass(MediaSegmentList, [{\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return this._list.length === 0;\n        }\n    }, {\n        key: \"clear\",\n        value: function clear() {\n            this._list = [];\n            this._lastAppendLocation = -1;\n        }\n    }, {\n        key: \"_searchNearestSegmentBefore\",\n        value: function _searchNearestSegmentBefore(beginDts) {\n            var list = this._list;\n            if (list.length === 0) {\n                return -2;\n            }\n            var last = list.length - 1;\n            var mid = 0;\n            var lbound = 0;\n            var ubound = last;\n\n            var idx = 0;\n\n            if (beginDts < list[0].originDts) {\n                idx = -1;\n                return idx;\n            }\n\n            while (lbound <= ubound) {\n                mid = lbound + Math.floor((ubound - lbound) / 2);\n                if (mid === last || beginDts > list[mid].lastSample.originDts && beginDts < list[mid + 1].originDts) {\n                    idx = mid;\n                    break;\n                } else if (list[mid].originDts < beginDts) {\n                    lbound = mid + 1;\n                } else {\n                    ubound = mid - 1;\n                }\n            }\n            return idx;\n        }\n    }, {\n        key: \"_searchNearestSegmentAfter\",\n        value: function _searchNearestSegmentAfter(beginDts) {\n            return this._searchNearestSegmentBefore(beginDts) + 1;\n        }\n    }, {\n        key: \"append\",\n        value: function append(segment) {\n            var list = this._list;\n            var lastAppendIdx = this._lastAppendLocation;\n            var insertIdx = 0;\n\n            if (lastAppendIdx !== -1 && lastAppendIdx < list.length && segment.originStartDts >= list[lastAppendIdx].lastSample.originDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && segment.originStartDts < list[lastAppendIdx + 1].originStartDts)) {\n                insertIdx = lastAppendIdx + 1; // use cached location idx\n            } else {\n                if (list.length > 0) {\n                    insertIdx = this._searchNearestSegmentBefore(segment.originStartDts) + 1;\n                }\n            }\n\n            this._lastAppendLocation = insertIdx;\n            this._list.splice(insertIdx, 0, segment);\n        }\n    }, {\n        key: \"getLastSegmentBefore\",\n        value: function getLastSegmentBefore(beginDts) {\n            var idx = this._searchNearestSegmentBefore(beginDts);\n            if (idx >= 0) {\n                return this._list[idx];\n            } else {\n                // -1\n                return null;\n            }\n        }\n    }, {\n        key: \"getLastSampleBefore\",\n        value: function getLastSampleBefore(beginDts) {\n            var segment = this.getLastSegmentBefore(beginDts);\n            if (segment !== null) {\n                return segment.lastSample;\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: \"getLastRAPBefore\",\n        value: function getLastRAPBefore(beginDts) {\n            var segmentIdx = this._searchNearestSegmentBefore(beginDts);\n            var randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n            while (randomAccessPoints.length === 0 && segmentIdx > 0) {\n                segmentIdx--;\n                randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n            }\n            if (randomAccessPoints.length > 0) {\n                return randomAccessPoints[randomAccessPoints.length - 1];\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: \"type\",\n        get: function get() {\n            return this._type;\n        }\n    }, {\n        key: \"length\",\n        get: function get() {\n            return this._list.length;\n        }\n    }]);\n\n    return MediaSegmentList;\n}();\n\nexports.default = MediaSegmentList;\n\n//# sourceURL=webpack://xgplayer-flv/./src/models/MediaSegmentList.js?");

/***/ }),

/***/ "./src/models/Store.js":
/*!*****************************!*\
  !*** ./src/models/Store.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MediaInfo = __webpack_require__(/*! ./MediaInfo */ \"./src/models/MediaInfo.js\");\n\nvar _MediaInfo2 = _interopRequireDefault(_MediaInfo);\n\nvar _sniffer = __webpack_require__(/*! ../utils/sniffer */ \"./src/utils/sniffer.js\");\n\nvar _sniffer2 = _interopRequireDefault(_sniffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Store = function () {\n  function Store() {\n    _classCallCheck(this, Store);\n\n    this.state = {\n      isLe: _sniffer2.default.isLe,\n      _hasAudio: false,\n      _hasVideo: false,\n      _mediaInfo: new _MediaInfo2.default(),\n      _metaData: null,\n      _videoTrack: { type: 'video', id: 1, samples: [], length: 0 },\n      _audioTrack: { type: 'audio', id: 2, samples: [], length: 0 },\n      _videoMetaData: null,\n      _audioMetaData: null,\n      _audioInitialMetadataDispatched: false,\n      _videoInitialMetadataDispatched: false,\n      tags: [],\n      timeStampBase: 0,\n      hasVideoFlagOverrided: false,\n      hasAudioFlagOverrided: false,\n      timeScale: 1000,\n      duration: 0,\n      isLive: false,\n      durationOverrided: false,\n      naluLengthSize: 4,\n      _referFrameRate: {\n        fixed: true,\n        fps: 23.976,\n        fpsNum: 23976,\n        fpsDen: 1000\n      },\n      metaEndPosition: -1\n    };\n\n    this.methods = {\n      _isInitialMetadataDispatched: function () {\n        var _state = this.state,\n            _hasAudio = _state._hasAudio,\n            _hasVideo = _state._hasVideo,\n            _audioInitialMetadataDispatched = _state._audioInitialMetadataDispatched,\n            _videoInitialMetadataDispatched = _state._videoInitialMetadataDispatched;\n\n        if (_hasAudio && _hasVideo) {\n          // both audio & video\n          return _audioInitialMetadataDispatched && _videoInitialMetadataDispatched;\n        }\n        if (_hasAudio && !_hasVideo) {\n          // audio only\n          return this._audioInitialMetadataDispatched;\n        }\n        if (!_hasAudio && _hasVideo) {\n          // video only\n          return _videoInitialMetadataDispatched;\n        }\n        return false;\n      }.bind(this)\n    };\n  }\n\n  _createClass(Store, [{\n    key: 'clearTags',\n    value: function clearTags() {\n      this.state.tags = [];\n    }\n  }, {\n    key: 'referFrameRate',\n    get: function get() {\n      return this.state._referFrameRate;\n    },\n    set: function set(val) {\n      this.state._referFrameRate = val;\n    }\n  }, {\n    key: 'mediaInfo',\n    set: function set(mediaInfo) {\n      this.state._mediaInfo = mediaInfo;\n    },\n    get: function get() {\n      return this.state._mediaInfo;\n    }\n  }, {\n    key: 'metaData',\n    get: function get() {\n      return this.state._metaData;\n    },\n    set: function set(v) {\n      this.state._metaData = v;\n    }\n  }, {\n    key: 'hasMetaData',\n    get: function get() {\n      return this.state._metaData !== null;\n    }\n  }, {\n    key: 'audioTrack',\n    set: function set(val) {\n      this.state._audioTrack = val;\n    },\n    get: function get() {\n      return this.state._audioTrack;\n    }\n  }, {\n    key: 'videoTrack',\n    set: function set(val) {\n      this.state._videoTrack = val;\n    },\n    get: function get() {\n      return this.state._videoTrack;\n    }\n  }, {\n    key: 'hasAudio',\n    set: function set(val) {\n      this.state._hasAudio = val;\n      this.state._mediaInfo.hasAudio = val;\n    },\n    get: function get() {\n      return this.state._hasAudio;\n    }\n  }, {\n    key: 'hasVideo',\n    set: function set(val) {\n      this.state._hasVideo = val;\n      this.state._mediaInfo.hasVideo = val;\n    },\n    get: function get() {\n      return this.state._hasVideo;\n    }\n  }, {\n    key: 'videoMetaData',\n    set: function set(val) {\n      this.state._videoMetaData = val;\n    },\n    get: function get() {\n      return this.state._videoMetaData;\n    }\n  }, {\n    key: 'audioMetaData',\n    set: function set(val) {\n      this.state._audioMetaData = val;\n    },\n    get: function get() {\n      return this.state._audioMetaData;\n    }\n  }, {\n    key: 'keyframes',\n    get: function get() {\n      return this.state._mediaInfo.keyframes;\n    }\n  }, {\n    key: 'isSeekable',\n    get: function get() {\n      return this.state._mediaInfo.hasKeyframes;\n    }\n  }, {\n    key: 'isLe',\n    get: function get() {\n      return this.state.isLe;\n    }\n  }, {\n    key: 'hasInitialMetaDispatched',\n    get: function get() {\n      var _state2 = this.state,\n          _hasAudio = _state2._hasAudio,\n          _hasVideo = _state2._hasVideo,\n          _audioInitialMetadataDispatched = _state2._audioInitialMetadataDispatched,\n          _videoInitialMetadataDispatched = _state2._videoInitialMetadataDispatched;\n\n      if (_hasAudio && _hasVideo) {\n        return _audioInitialMetadataDispatched && _videoInitialMetadataDispatched;\n      }\n      if (_hasAudio && !_hasVideo) {\n        return this._audioInitialMetadataDispatched;\n      }\n      if (!_hasAudio && _hasVideo) {\n        return _videoInitialMetadataDispatched;\n      }\n      return false;\n    }\n  }, {\n    key: 'videoTimeScale',\n    get: function get() {\n      return this.state.timeScale;\n    }\n  }, {\n    key: 'metaEndPosition',\n    get: function get() {\n      return this.state.metaEndPosition;\n    },\n    set: function set(pos) {\n      this.state.metaEndPosition = pos;\n    }\n  }, {\n    key: 'isLive',\n    get: function get() {\n      return this.state.isLive;\n    },\n    set: function set(val) {\n      this.state.isLive = val;\n    }\n  }]);\n\n  return Store;\n}();\n\nexports.default = Store;\n\n//# sourceURL=webpack://xgplayer-flv/./src/models/Store.js?");

/***/ }),

/***/ "./src/models/Tag.js":
/*!***************************!*\
  !*** ./src/models/Tag.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FlvTag = function () {\n    function FlvTag() {\n        _classCallCheck(this, FlvTag);\n\n        this.tagType = -1;\n        this.bodySize = -1;\n        this.tagSize = -1;\n        this.position = -1;\n        this.Timestamp = -1;\n        this.StreamID = -1;\n        this.body = -1;\n        this.time = -1;\n        this.arr = [];\n    }\n\n    _createClass(FlvTag, [{\n        key: 'getTime',\n        value: function getTime() {\n            this.arr = [];\n            for (var i = 0; i < this.Timestamp.length; i++) {\n                this.arr.push(this.Timestamp[i].toString(16).length === 1 ? '0' + this.Timestamp[i].toString(16) : this.Timestamp[i].toString(16));\n            }\n            this.arr.pop();\n            var time = this.arr.join('');\n            this.time = parseInt(time, 16);\n            return parseInt(time, 16);\n        }\n    }]);\n\n    return FlvTag;\n}();\n\nexports.default = FlvTag;\n\n//# sourceURL=webpack://xgplayer-flv/./src/models/Tag.js?");

/***/ }),

/***/ "./src/parse/FlvParser.js":
/*!********************************!*\
  !*** ./src/parse/FlvParser.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Demuxer2 = __webpack_require__(/*! ./demux/Demuxer */ \"./src/parse/demux/Demuxer.js\");\n\nvar _Demuxer3 = _interopRequireDefault(_Demuxer2);\n\nvar _Buffer = __webpack_require__(/*! ../write/Buffer */ \"./src/write/Buffer.js\");\n\nvar _Buffer2 = _interopRequireDefault(_Buffer);\n\nvar _Tag = __webpack_require__(/*! ../models/Tag */ \"./src/models/Tag.js\");\n\nvar _Tag2 = _interopRequireDefault(_Tag);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FlvParser = function (_Demuxer) {\n  _inherits(FlvParser, _Demuxer);\n\n  function FlvParser(store) {\n    _classCallCheck(this, FlvParser);\n\n    var _this = _possibleConstructorReturn(this, (FlvParser.__proto__ || Object.getPrototypeOf(FlvParser)).call(this, store));\n\n    _this.CLASS_NAME = _this.constructor.name;\n    _this.temp_u8a = null;\n    _this.dataLen = 0;\n    _this.stop = false;\n    _this.index = 0; // record the position in single round\n    _this.offset = 0;\n    _this.filePosition = 0; // record current file position\n    _this.firstFlag = true;\n    return _this;\n  }\n\n  _createClass(FlvParser, [{\n    key: 'seek',\n    value: function seek() {\n      this.offset = 0;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.temp_u8a = null;\n      this.dataLen = 0;\n      this.stop = false;\n      this.index = 0; // record the position in single round\n      this.offset = 0;\n      this.filePosition = 0;\n    }\n  }, {\n    key: 'setFlv',\n    value: function setFlv(flv_u8a) {\n      this.stop = false;\n      this.index = 0;\n      this.offset = 0;\n      var temp_u8a = this.temp_u8a = flv_u8a;\n      this.dataLen = this.temp_u8a.length;\n\n      if (!this.firstFlag) {\n        return this.parseData();\n      } else if (temp_u8a.length > 13 && FlvParser.isFlvHead(temp_u8a)) {\n        this.parseHead();\n        this.readData(9); // 跳过头部\n        this.readData(4); // 跳过下一个记录头部size的 int32\n        this.parseData();\n        this.firstFlag = false;\n        this.filePosition += this.offset;\n        return this.offset;\n      } else {\n        return this.offset;\n      }\n    }\n  }, {\n    key: 'parseData',\n    value: function parseData() {\n      var u8a_length = this.temp_u8a.length;\n\n      while (this.index < u8a_length && !this.stop) {\n        this.offset = this.index;\n        var tag = new _Tag2.default();\n        if (this.unreadLength >= 11) {\n          // 可以读出头部信息\n          tag.position = this.filePosition + this.offset;\n          tag.tagType = this.readData(1)[0];\n          tag.bodySize = this.readData(3);\n          tag.Timestamp = this.readData(4);\n          tag.StramId = this.readData(3);\n        } else {\n          this.stop = true;\n          continue;\n        }\n        if (this.unreadLength >= this.getBodySize(tag.bodySize) + 4) {\n          tag.body = this.readData(this.getBodySize(tag.bodySize));\n          tag.tagSize = this.readData(4);\n          var _store$state = this._store.state,\n              tags = _store$state.tags,\n              _hasVideo = _store$state._hasVideo,\n              _hasAudio = _store$state._hasAudio;\n\n          switch (tag.tagType) {\n            case 9:\n              _hasVideo && tags.push(tag);\n              break;\n            case 8:\n              _hasAudio && tags.push(tag);\n              break;\n            case 18:\n              tags.push(tag);\n              break;\n          }\n        } else {\n          this.stop = true;\n          continue;\n        }\n\n        this.offset = this.index;\n      }\n      this.filePosition += this.offset;\n      this.temp_u8a = null;\n      return this.offset;\n    }\n\n    /**\n     * @param sizeArr\n     * @return\n     */\n\n  }, {\n    key: 'getBodySize',\n    value: function getBodySize(sizeArr) {\n      return _Buffer2.default.readAsInt(sizeArr);\n    }\n  }, {\n    key: 'parseHead',\n    value: function parseHead() {\n      var temp_u8a = this.temp_u8a,\n          _store = this._store;\n\n      var result = {\n        match: false\n      };\n      if (temp_u8a[3] !== 1) {\n        return result;\n      }\n      var flag = temp_u8a[4];\n      var hasAudio = (flag & 4) >>> 2 !== 0;\n      var hasVideo = (flag & 1) !== 0;\n\n      if (!hasAudio && !hasVideo) {\n        return result;\n      }\n\n      _store.hasAudio = hasAudio;\n      _store.hasVideo = hasVideo;\n    }\n  }, {\n    key: 'readData',\n    value: function readData(length) {\n      var _index = this.index;\n      this.index += length;\n      return this.temp_u8a.slice(_index, _index + length);\n    }\n  }, {\n    key: 'unreadLength',\n    get: function get() {\n      return this.dataLen - this.index;\n    }\n  }], [{\n    key: 'isFlvHead',\n    value: function isFlvHead(temp_u8a) {\n      var firstThreeChars = [temp_u8a[0], temp_u8a[1], temp_u8a[2]];\n      return String.fromCharCode.apply(String, firstThreeChars) === 'FLV';\n    }\n  }]);\n\n  return FlvParser;\n}(_Demuxer3.default);\n\nexports.default = FlvParser;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/FlvParser.js?");

/***/ }),

/***/ "./src/parse/MSE.js":
/*!**************************!*\
  !*** ./src/parse/MSE.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _eventEmitter = __webpack_require__(/*! event-emitter */ \"./node_modules/event-emitter/index.js\");\n\nvar _eventEmitter2 = _interopRequireDefault(_eventEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar count = 0;\n\nvar MSE = function () {\n  function MSE() {\n    var codecs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'video/mp4; codecs=\"avc1.64001E, mp4a.40.5\"';\n\n    _classCallCheck(this, MSE);\n\n    this.count = count++;\n    var self = this;\n    (0, _eventEmitter2.default)(this);\n    this.codecs = codecs;\n    this.mediaSource = new window.MediaSource();\n    this.url = window.URL.createObjectURL(this.mediaSource);\n\n    this.handleSourceOpen = this.onSourceOpen.bind(this);\n    this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen);\n\n    this.mediaSource.addEventListener('sourceclose', function () {\n      self.emit('sourceclose');\n    });\n  }\n\n  _createClass(MSE, [{\n    key: 'onSourceOpen',\n    value: function onSourceOpen() {\n      var self = this;\n      self.sourceBuffer = self.mediaSource.addSourceBuffer(self.codecs);\n      self.sourceBuffer.addEventListener('error', function (e) {\n        self.emit('error', {\n          type: 'sourceBuffer',\n          error: e\n        });\n      });\n      self.sourceBuffer.addEventListener('updateend', function (e) {\n        self.emit('updateend');\n      });\n      self.emit('sourceopen');\n      self.sourceBuffer.addEventListener('error', function (e) {\n        self.emit('error', {\n          type: 'mediaSource',\n          error: e\n        });\n      });\n    }\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(buffer) {\n      var sourceBuffer = this.sourceBuffer;\n      if (sourceBuffer.updating === false && this.state === 'open') {\n        sourceBuffer.appendBuffer(buffer);\n        return true;\n      } else {\n        if (this.state === 'closed') {\n          this.emit('error', {\n            type: 'sourceBuffer',\n            error: new Error('mediaSource is not attached to video or mediaSource is closed')\n          });\n        } else if (this.state === 'ended') {\n          this.emit('error', {\n            type: 'sourceBuffer',\n            error: new Error('mediaSource is closed')\n          });\n        } else {\n          if (sourceBuffer.updating === true) {\n            this.emit('warn', {\n              type: 'sourceBuffer',\n              error: new Error('mediaSource is busy')\n            });\n          }\n          return false;\n        }\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      // this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen)\n      this.__ee__ = {};\n      // this.mediaSource = null\n      // this.endOfStream()\n    }\n  }, {\n    key: 'removeBuffer',\n    value: function removeBuffer(start, end) {\n      this.sourceBuffer.remove(start, end);\n    }\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream() {\n      if (this.mediaSource.readyState === 'open') {\n        this.mediaSource.endOfStream();\n      }\n    }\n  }, {\n    key: 'state',\n    get: function get() {\n      return this.mediaSource.readyState;\n    }\n  }, {\n    key: 'duration',\n    get: function get() {\n      return this.mediaSource.duration;\n    },\n    set: function set(value) {\n      this.mediaSource.duration = value;\n    }\n  }], [{\n    key: 'isSupported',\n    value: function isSupported(codecs) {\n      return window.MediaSource && window.MediaSource.isTypeSupported(codecs);\n    }\n  }]);\n\n  return MSE;\n}();\n\nexports.default = MSE;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/MSE.js?");

/***/ }),

/***/ "./src/parse/MainParser.js":
/*!*********************************!*\
  !*** ./src/parse/MainParser.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Mp4remux = __webpack_require__(/*! ./remux/Mp4remux */ \"./src/parse/remux/Mp4remux.js\");\n\nvar _Mp4remux2 = _interopRequireDefault(_Mp4remux);\n\nvar _Demuxer2 = __webpack_require__(/*! ./demux/Demuxer */ \"./src/parse/demux/Demuxer.js\");\n\nvar _Demuxer3 = _interopRequireDefault(_Demuxer2);\n\nvar _FlvParser = __webpack_require__(/*! ./FlvParser */ \"./src/parse/FlvParser.js\");\n\nvar _FlvParser2 = _interopRequireDefault(_FlvParser);\n\nvar _TagDemuxer = __webpack_require__(/*! ./demux/TagDemuxer */ \"./src/parse/demux/TagDemuxer.js\");\n\nvar _TagDemuxer2 = _interopRequireDefault(_TagDemuxer);\n\nvar _Store = __webpack_require__(/*! ../models/Store */ \"./src/models/Store.js\");\n\nvar _Store2 = _interopRequireDefault(_Store);\n\nvar _VodTask = __webpack_require__(/*! ../tasks/VodTask */ \"./src/tasks/VodTask.js\");\n\nvar _VodTask2 = _interopRequireDefault(_VodTask);\n\nvar _LiveTask = __webpack_require__(/*! ../tasks/LiveTask */ \"./src/tasks/LiveTask.js\");\n\nvar _LiveTask2 = _interopRequireDefault(_LiveTask);\n\nvar _types = __webpack_require__(/*! ../constants/types */ \"./src/constants/types.js\");\n\nvar _Buffer = __webpack_require__(/*! ../write/Buffer */ \"./src/write/Buffer.js\");\n\nvar _Buffer2 = _interopRequireDefault(_Buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar id = 0;\n\nvar MainParser = function (_Demuxer) {\n  _inherits(MainParser, _Demuxer);\n\n  function MainParser(config, player) {\n    _classCallCheck(this, MainParser);\n\n    var _this = _possibleConstructorReturn(this, (MainParser.__proto__ || Object.getPrototypeOf(MainParser)).call(this));\n\n    _this.uid = id++;\n    _this.CLASS_NAME = _this.constructor.name;\n    _this._config = config;\n    _this._player = player;\n    _this._tempBaseTime = 0;\n    _this.firstFlag = true;\n    _this._store = new _Store2.default();\n    _this._store.isLive = config.isLive || false;\n    _this.flvParser = new _FlvParser2.default(_this._store);\n    _this.tagDemuxer = new _TagDemuxer2.default(_this._store);\n    _this._mp4remuxer = new _Mp4remux2.default();\n    _this._mp4remuxer.isLive = config.isLive || false;\n    _this.buffer = new _Buffer2.default();\n    _this.bufferKeyframes = new Set();\n    _this.META_CHUNK_SIZE = 2 * Math.pow(10, 5);\n    _this.CHUNK_SIZE = Math.pow(10, 6);\n    _this.ftyp_moov = null;\n    _this.isSourceOpen = false;\n    _this._isNewSegmentsArrival = false;\n    _this.isSeeking = false;\n    _this.loadTask = null;\n    _this.range = {\n      start: -1,\n      end: -1\n    };\n    _this._isMediaInfoInited = false;\n    _this._pendingFragments = [];\n    _this._pendingRemoveRange = [];\n    _this.err_cnt = 0;\n    _this.requestConfig = {\n      mode: _this._config.cors ? 'cors' : 'same-origin'\n    };\n    _this.initEventBind();\n    return _this;\n  }\n\n  _createClass(MainParser, [{\n    key: 'startLoadData',\n    value: function startLoadData() {\n      if (!this._config.isLive) {\n        this.initMeta();\n      } else {\n        this.initLiveStream();\n      }\n    }\n  }, {\n    key: 'initLiveStream',\n    value: function initLiveStream() {\n      new _LiveTask2.default(this._config.url, this.requestConfig).run(this.loadLiveData.bind(this));\n    }\n  }, {\n    key: 'loadLiveData',\n    value: function loadLiveData(buffer) {\n      if (buffer === undefined) {\n        this.emit('live-end');\n      }\n      this.buffer.write(new Uint8Array(buffer));\n      var offset = this.setFlv(this.buffer.buffer);\n      this.buffer.buffer = this.buffer.buffer.slice(offset);\n    }\n  }, {\n    key: 'initMeta',\n    value: function initMeta() {\n      var _this2 = this;\n\n      var self = this;\n      var Resolver = {\n        resolveChunk: function resolveChunk(_ref) {\n          var timeStamp = _ref.timeStamp,\n              buffer = _ref.buffer;\n\n          if (timeStamp !== self.loadTask.timeStamp) return;\n          self.err_cnt = 0;\n          self.buffer.write(new Uint8Array(buffer));\n          var offset = self.setFlv(self.buffer.buffer);\n          self.buffer.buffer = self.buffer.buffer.slice(offset);\n          if (!self.isMediaInfoReady) {\n            self.initMeta();\n          }\n        }\n      };\n      this.range = {\n        start: this.range.end + 1,\n        end: this.range.end + this.META_CHUNK_SIZE\n      };\n      var loadData = function loadData() {\n        return _this2.loadMetaData(_this2.range.start, _this2.range.end).then(Resolver.resolveChunk).catch(function (e) {\n          _this2.log(e.message);\n          if (_this2.err_cnt >= 3) {\n            _this2._player.emit('error', '加载视频失败');\n            return;\n          }\n          _this2.err_cnt += 1;\n          loadData();\n        });\n      };\n      return loadData();\n    }\n  }, {\n    key: 'loadSegments',\n    value: function loadSegments(changeRange) {\n      var _this3 = this;\n\n      var currentTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var preloadTime = arguments[2];\n\n      this._isNewSegmentsArrival = false;\n      var resolveChunk = function resolveChunk(_ref2) {\n        var timeStamp = _ref2.timeStamp,\n            buffer = _ref2.buffer;\n\n        if (_this3.isTempPlayer) {\n          _this3.isTempPlayer = false;\n        }\n        if (timeStamp !== _this3.loadTask.timeStamp) return;\n        _this3.err_cnt = 0;\n        _this3.buffer.write(new Uint8Array(buffer));\n        if (_this3.isSeeking) {\n          _this3._pendingFragments = [];\n        }\n        var offset = _this3.setFlv(_this3.buffer.buffer);\n        _this3.buffer.buffer = _this3.buffer.buffer.slice(offset);\n        if (!_this3._isNewSegmentsArrival) {\n          _this3.loadSegments(true);\n        } else {\n          _this3.isSeeking = false;\n        }\n      };\n      if (changeRange) {\n        var _range = this.range;\n\n        if (this.getNextRangeEnd(currentTime, preloadTime) <= _range.end) {\n          return Promise.resolve();\n        }\n\n        this.range = {\n          start: this.range.end + 1,\n          end: currentTime === undefined ? this.range.end + this.CHUNK_SIZE - 1 : this.getNextRangeEnd(currentTime, preloadTime) - 1\n        };\n\n        if (this.range.start >= this.range.end || !this.range.end) {\n          this.range = _range;\n          return Promise.resolve();\n        }\n      }\n      var loadData = function loadData() {\n        if (_this3.stop) return;\n        return _this3._loadSegmentsData(_this3.range.start, _this3.range.end).then(resolveChunk).catch(function (e) {\n          if (_this3.err_cnt >= 3) {\n            _this3._player.emit('error', '加载视频失败');\n            return;\n          }\n          _this3.err_cnt += 1;\n          loadData();\n        });\n      };\n      return loadData();\n    }\n  }, {\n    key: 'getNextRangeEnd',\n    value: function getNextRangeEnd(start, preloadTime) {\n      var _store = this._store,\n          _store$keyframes = _store.keyframes,\n          times = _store$keyframes.times,\n          filePositions = _store$keyframes.filePositions,\n          videoTimeScale = _store.videoTimeScale;\n\n      if (!times || !filePositions) {\n        return this.range.end + this.CHUNK_SIZE;\n      }\n      start *= videoTimeScale;\n\n      var expectEnd = start + preloadTime * videoTimeScale;\n      if (expectEnd > times[times.length - 1]) {\n        return filePositions[filePositions.length - 1];\n      }\n      var left = 0;\n      var right = times.length - 1;\n      var index = void 0;\n\n      while (left <= right) {\n        var mid = Math.floor((right + left) / 2);\n        if (times[mid] <= expectEnd && expectEnd <= times[mid + 1]) {\n          index = mid + 1;\n          break;\n        } else if (left === right) {\n          index = mid;\n          break;\n        } else if (expectEnd < times[mid]) {\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      }\n\n      return index ? filePositions[index] : undefined;\n    }\n  }, {\n    key: '_loadSegmentsData',\n    value: function _loadSegmentsData() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start + this.CHUNK_SIZE;\n\n      this.loadTask = new _VodTask2.default(this._config.url, [start, end], this.requestConfig);\n      return this.loadTask.promise;\n    }\n  }, {\n    key: 'loadMetaData',\n    value: function loadMetaData() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start + this.META_CHUNK_SIZE;\n\n      this.loadTask = new _VodTask2.default(this._config.url, [start, end], this.requestConfig);\n      return this.loadTask.promise;\n    }\n  }, {\n    key: 'setFlvFirst',\n    value: function setFlvFirst(arrayBuff, baseTime) {\n      var offset = this.flvParser.setFlv(new Uint8Array(arrayBuff));\n      var tags = this._store.state.tags;\n\n\n      if (tags.length) {\n        if (tags[0].tagType !== 18) {\n          throw new Error('flv file without metadata tag');\n        }\n\n        if (this._tempBaseTime !== 0 && this._tempBaseTime === tags[0].getTime()) {\n          this._store.state._timestampBase = 0;\n        }\n\n        this.tagDemuxer.resolveTags(tags);\n      }\n\n      this.firstFlag = false;\n      return offset;\n    }\n  }, {\n    key: 'setFlvUsually',\n    value: function setFlvUsually(arrayBuff, baseTime) {\n      this.isParsing = true;\n      var offset = this.flvParser.setFlv(new Uint8Array(arrayBuff));\n      var tags = this._store.state.tags;\n\n      if (tags.length) {\n        this.tagDemuxer.resolveTags(tags);\n      }\n      return offset;\n    }\n  }, {\n    key: 'handleDataReady',\n    value: function handleDataReady(audioTrack, videoTrack) {\n      // if (this.isTempPlayer) return\n      this._mp4remuxer.remux(audioTrack, videoTrack);\n    }\n  }, {\n    key: 'handleMetaDataReady',\n    value: function handleMetaDataReady(type, meta) {\n      this._mp4remuxer.onMetaDataReady(type, meta);\n    }\n  }, {\n    key: 'handleError',\n    value: function handleError(e) {\n      this.error(e);\n    }\n  }, {\n    key: 'handleNewMediaFragment',\n    value: function handleNewMediaFragment(newFrag) {\n      var _this4 = this;\n\n      // if (this.isTempPlayer) return\n      this._isNewSegmentsArrival = true;\n      this._pendingFragments.push(newFrag);\n      var randomAccessPoints = newFrag.fragment.randomAccessPoints;\n\n      if (randomAccessPoints && randomAccessPoints.length) {\n        randomAccessPoints.forEach(function (rap) {\n          _this4.bufferKeyframes.add(rap.dts);\n        });\n      }\n      if (!this.isSourceOpen) {\n        return;\n      }\n      if (this._pendingFragments.length) {\n        var fragment = this._pendingFragments.shift();\n        if (!this.handleMediaFragment(fragment)) {\n          this._pendingFragments.unshift(fragment);\n        } else {\n          console.log(fragment);\n          this.handleSeekEnd();\n          this._player.emit('cacheupdate', this._player);\n        }\n      }\n    }\n  }, {\n    key: 'handleMediaInfoReady',\n    value: function handleMediaInfoReady(mediaInfo) {\n      if (this._isMediaInfoInited) {\n        return;\n      }\n\n      var FTYP_MOOV = this._mp4remuxer.onMediaInfoReady(mediaInfo);\n      if (!this.ftyp_moov) {\n        this.ftyp_moov = FTYP_MOOV;\n        this.emit('ready', FTYP_MOOV);\n      }\n      this._isMediaInfoInited = true;\n    }\n  }, {\n    key: 'initEventBind',\n    value: function initEventBind() {\n      var prefix = 'demuxer_';\n      var handleError = this.handleError,\n          handleDataReady = this.handleDataReady,\n          handleMetaDataReady = this.handleMetaDataReady,\n          handleMediaInfoReady = this.handleMediaInfoReady,\n          handleNewMediaFragment = this.handleNewMediaFragment;\n\n      this.on('mediaFragment', handleNewMediaFragment.bind(this));\n      this.on(_types.EventTypes.ERROR, handleError.bind(this));\n      this.on(prefix + 'data_ready', handleDataReady.bind(this));\n      this.on(prefix + 'meta_data_ready', handleMetaDataReady.bind(this));\n      this.on(prefix + 'media_info_ready', handleMediaInfoReady.bind(this));\n    }\n  }, {\n    key: 'replay',\n    value: function replay() {\n      this.isSourceOpen = false;\n      this.range = {\n        start: this._store.metaEndPosition,\n        end: this.getNextRangeEnd(0, this._config.preloadTime) - 1\n        // this.firstFlag = true;\n      };this._mp4remuxer.seek();\n      this.flvParser.seek();\n      this.clearBuffer();\n      this.loadSegments(false);\n    }\n  }, {\n    key: 'clearBuffer',\n    value: function clearBuffer() {\n      this._pendingFragments = [];\n      this._pendingRemoveRange = [];\n    }\n  }, {\n    key: 'unbindEvents',\n    value: function unbindEvents() {\n      var prefix = 'demuxer_';\n      this.removeAllListeners(_types.EventTypes.ERROR);\n      this.removeAllListeners(prefix + 'data_ready');\n      this.removeAllListeners(prefix + 'meta_data_ready');\n      this.removeAllListeners(prefix + 'media_info_ready');\n      this.removeAllListeners('mediaFragment');\n      this.handleNewMediaFragment = function () {\n        return null;\n      };\n      this.handleDataReady = function () {\n        return null;\n      };\n      this.handleMetaDataReady = function () {\n        return null;\n      };\n      this.handleMediaInfoReady = function () {\n        return null;\n      };\n      this.handleNewMediaFragment = function () {\n        return null;\n      };\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._mp4remuxer.destroy();\n      this.flvParser.destroy();\n      this.tagDemuxer.destroy();\n      this._mp4remuxer = null;\n      this.flvParser = null;\n      this.tagDemuxer = null;\n      this.loadSegments = function () {\n        return null;\n      };\n      this.clearBuffer();\n      this.stop = true;\n    }\n  }, {\n    key: 'seek',\n    value: function seek(target) {\n      console.log(this.uid);\n      this.loadTask.cancel();\n      var _store2 = this._store,\n          _store2$keyframes = _store2.keyframes,\n          keyframes = _store2$keyframes === undefined ? {} : _store2$keyframes,\n          videoTimeScale = _store2.videoTimeScale;\n\n      var seekStart = target * videoTimeScale;\n      var startFilePos = void 0;\n      var endFilePos = void 0;\n      var length = Math.min(keyframes.filePositions.length, keyframes.times.length);\n      var preloadTime = this._config.preloadTime;\n\n\n      function getEndFilePos(time, idx) {\n        if (idx === keyframes.times.length) {\n          endFilePos = idx;\n          return false;\n        }\n        if (time <= preloadTime && preloadTime <= keyframes.times[idx + 1]) {\n          endFilePos = idx;\n          return false;\n          // 需要处理EOF的情况\n        }\n        return true;\n      }\n\n      var lo = 0;\n      var hi = length - 2;\n      while (lo <= hi) {\n        var mid = Math.floor((lo + hi) / 2);\n        var currentTime = keyframes.times[mid];\n        var nextTime = keyframes.times[mid + 1] ? keyframes.times[mid + 1] : Number.MAX_SAFE_INTEGER;\n        if (currentTime <= seekStart && seekStart <= nextTime || lo === hi) {\n          startFilePos = mid;\n          preloadTime = preloadTime * videoTimeScale + seekStart;\n          keyframes.times.every(getEndFilePos);\n          break;\n        } else if (seekStart < currentTime) {\n          hi = mid - 1;\n        } else {\n          lo = mid + 1;\n        }\n      }\n\n      if (!this.isSeeking) {\n        this.isSeeking = true;\n      } else {\n        // this.tagDemuxer = new tagDemuxer(this._store);\n        this._store.clearTags();\n        // return;\n      }\n      this._pendingFragments = [];\n      this._mp4remuxer.seek();\n      this.flvParser.seek();\n      _VodTask2.default.clear();\n      this.range = {\n        start: keyframes.filePositions[startFilePos],\n        end: keyframes.filePositions[endFilePos] - 1 || ''\n      };\n      this.buffer = new _Buffer2.default();\n      this.loadSegments(false);\n    }\n  }, {\n    key: 'setFlv',\n    get: function get() {\n      return this.firstFlag ? this.setFlvFirst : this.setFlvUsually;\n    }\n  }, {\n    key: 'isMediaInfoReady',\n    get: function get() {\n      return this._store.mediaInfo.isComplete;\n    }\n  }, {\n    key: 'videoDuration',\n    get: function get() {\n      return this._store.mediaInfo.duration;\n    }\n  }, {\n    key: 'hasPendingFragments',\n    get: function get() {\n      return !!this._pendingFragments.length;\n    }\n  }, {\n    key: 'pendingFragments',\n    get: function get() {\n      return this._pendingFragments;\n    }\n  }, {\n    key: 'videoTimeScale',\n    get: function get() {\n      return this._store.videoTimeScale;\n    }\n  }, {\n    key: 'hasPendingRemoveRanges',\n    get: function get() {\n      return this._pendingRemoveRange.length;\n    }\n  }, {\n    key: 'pendingRemoveRanges',\n    get: function get() {\n      return this._pendingRemoveRange;\n    }\n  }, {\n    key: 'isSeekable',\n    get: function get() {\n      return this._store.isSeekable;\n    }\n  }]);\n\n  return MainParser;\n}(_Demuxer3.default);\n\nexports.default = MainParser;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/MainParser.js?");

/***/ }),

/***/ "./src/parse/SPSParser.js":
/*!********************************!*\
  !*** ./src/parse/SPSParser.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ExpGolomb = __webpack_require__(/*! ../utils/ExpGolomb */ \"./src/utils/ExpGolomb.js\");\n\nvar _ExpGolomb2 = _interopRequireDefault(_ExpGolomb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SPSParser = function () {\n    function SPSParser() {\n        _classCallCheck(this, SPSParser);\n    }\n\n    _createClass(SPSParser, null, [{\n        key: 'getProfileStr',\n        value: function getProfileStr(profileIdc) {\n            switch (profileIdc) {\n                case 66:\n                    return 'Baseline';\n                case 77:\n                    return 'Main';\n                case 88:\n                    return 'Extended';\n                case 100:\n                    return 'High';\n                case 110:\n                    return 'High10';\n                case 122:\n                    return 'High422';\n                case 244:\n                    return 'High444';\n                default:\n                    return 'Unknown';\n            }\n        }\n    }, {\n        key: 'getLevelStr',\n        value: function getLevelStr(levelIdc) {\n            return (levelIdc / 10).toFixed(1);\n        }\n    }, {\n        key: 'getChromaFormatStr',\n        value: function getChromaFormatStr(chroma) {\n            switch (chroma) {\n                case 420:\n                    return '4:2:0';\n                case 422:\n                    return '4:2:2';\n                case 444:\n                    return '4:4:4';\n                default:\n                    return 'Unknown';\n            }\n        }\n\n        /**\n         * read SPS\n         * @param originArr\n         */\n\n    }, {\n        key: 'parseSPS',\n        value: function parseSPS(originArr) {\n\n            var rbsp = SPSParser._ebsp2rbsp(originArr);\n\n            var stream = new _ExpGolomb2.default(rbsp);\n            var spsConfig = stream.readSPS();\n            var chromaFormat = spsConfig.chromaFormat,\n                levelIdc = spsConfig.levelIdc,\n                profileIdc = spsConfig.profileIdc;\n\n            spsConfig.profileString = SPSParser.getProfileStr(profileIdc);\n            spsConfig.levelString = SPSParser.getLevelStr(levelIdc);\n            spsConfig.chromaFormatString = SPSParser.getChromaFormatStr(chromaFormat);\n\n            return spsConfig;\n        }\n\n        //\n\n    }, {\n        key: '_ebsp2rbsp',\n        value: function _ebsp2rbsp(originArr) {\n            var originLen = originArr.byteLength;\n            var dist = new Uint8Array(originArr.byteLength);\n            var distSize = 0;\n\n            for (var i = 0, len = originLen; i < len; i++) {\n                if (i > 2 && originArr[i] === 3 && originArr[i - 1] === 0 && originArr[i - 2] === 0) {\n                    continue;\n                }\n                dist[distSize++] = originArr[i];\n            }\n\n            return new Uint8Array(dist.buffer, 0, distSize);\n        }\n    }]);\n\n    return SPSParser;\n}();\n\nexports.default = SPSParser;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/SPSParser.js?");

/***/ }),

/***/ "./src/parse/demux/AudioDemuxer.js":
/*!*****************************************!*\
  !*** ./src/parse/demux/AudioDemuxer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Demuxer2 = __webpack_require__(/*! ./Demuxer */ \"./src/parse/demux/Demuxer.js\");\n\nvar _Demuxer3 = _interopRequireDefault(_Demuxer2);\n\nvar _DataView4Read = __webpack_require__(/*! ../../utils/DataView4Read */ \"./src/utils/DataView4Read.js\");\n\nvar _DataView4Read2 = _interopRequireDefault(_DataView4Read);\n\nvar _types = __webpack_require__(/*! ../../constants/types */ \"./src/constants/types.js\");\n\nvar _sniffer = __webpack_require__(/*! ../../utils/sniffer */ \"./src/utils/sniffer.js\");\n\nvar _sniffer2 = _interopRequireDefault(_sniffer);\n\nvar _Buffer = __webpack_require__(/*! ../../write/Buffer */ \"./src/write/Buffer.js\");\n\nvar _Buffer2 = _interopRequireDefault(_Buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // refrence: https://github.com/video-dev/hls.js/blob/master/src/demux/adts.js\n\n// import { mp3Versions, mp3BitRate, audioSampleRate } from '../../constants/types';\n\n\nvar AudioDemuxer = function (_Demuxer) {\n    _inherits(AudioDemuxer, _Demuxer);\n\n    function AudioDemuxer(store) {\n        _classCallCheck(this, AudioDemuxer);\n\n        var _this = _possibleConstructorReturn(this, (AudioDemuxer.__proto__ || Object.getPrototypeOf(AudioDemuxer)).call(this, store));\n\n        _this.CLASS_NAME = _this.constructor.name;\n        _this.currentTag = null;\n        _this.data = new Uint8Array(0);\n        _this.readOffset = 0;\n        _this._store.audioMetaData = null;\n        return _this;\n    }\n\n    _createClass(AudioDemuxer, [{\n        key: 'resolve',\n        value: function resolve(tag) {\n            var store = this._store;\n            var track = store.audioTrack;\n\n            this.currentTag = tag;\n            this.data = tag.body;\n            var meta = store.audioMetaData;\n\n\n            if (!meta) {\n                meta = store.audioMetaData = {};\n                store.audioMetaData = this.initAudioMeta(meta);\n            }\n\n            var dv = new _DataView4Read2.default(tag.body.buffer, this);\n\n            var sound = dv.getUint8();\n\n            var soundFormatIdx = sound >>> 4,\n                //  UInt4\n            soundRate = (sound & 12) >>> 2,\n                //  UInt2\n            soundSize = (sound & 2) >>> 1,\n                //   UInt1\n            soundType = sound % 1; // UInt1\n\n            meta.audioSampleRate = _types.soundRateTypes[soundRate];\n            meta.channelCount = soundType === 0 ? 1 : 2;\n\n            if (soundFormatIdx !== 10 && soundFormatIdx !== 2) {\n                this.error('only support AAC Audio format so far');\n                return;\n            } else if (soundFormatIdx === 10) {\n                // AAC\n                var aacInfo = this._parseAACAudio();\n                if (!aacInfo) {\n                    return;\n                }\n\n                var aacData = aacInfo.data,\n                    sampleFreq = aacInfo.data.sampleFreq;\n\n                if (aacInfo.packetType === 0) {\n                    // AAC sequence header\n                    meta.sampleRate = sampleFreq;\n                    meta.channelCount = aacData.channelCount;\n                    meta.codec = aacData.codec;\n                    meta.manifestCodec = aacData.manifestCodec;\n                    meta.config = aacData.config;\n                    meta.refSampleDuration = 1024 / sampleFreq * meta.timeScale;\n                    if (store.hasInitialMetaDispatched) {\n                        if (store.videoTrack.length || store.audioTrack.length) {\n                            this.dispatch(_types.EventTypes.DATA_READY, store.videoTrack, store.audioTrack);\n                        }\n                    } else {\n                        store.state._audioInitialMetadataDispatched = true;\n                    }\n\n                    this.dispatch(_types.EventTypes.META_DATA_READY, 'audio', meta);\n\n                    var mi = store.mediaInfo;\n\n                    mi.audioCodec = meta.codec;\n                    mi.audioSampleRate = meta.sampleRate;\n                    mi.audioChannelCount = meta.channelCount;\n                    mi.audioConfig = meta.config;\n                    if (mi.hasVideo) {\n                        if (mi.videoCodec) {\n                            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n                            mi.codec = mi.mimeType.replace('x-flv', 'mp4');\n                        }\n                    } else {\n                        mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n                        mi.codec = mi.mimeType.replace('x-flv', 'mp4');\n                    }\n\n                    if (mi.isComplete) {\n                        this.dispatch(_types.EventTypes.MEDIA_INFO_READY, mi);\n                    }\n                } else if (aacInfo.packetType === 1) {\n                    // AAC raw frame data\n                    var dts = store.state.timeStampBase + this.currentTag.getTime();\n                    var aacSample = { unit: aacInfo.data, length: aacInfo.data.byteLength, dts: dts, pts: dts };\n                    track.samples.push(aacSample);\n                    track.length += aacInfo.data.length;\n                }\n            }\n\n            this.resetStatus();\n        }\n    }, {\n        key: '_parseAACAudio',\n        value: function _parseAACAudio() {\n            if (this.unreadLength <= 1) {\n                return;\n            }\n            var aacData = {};\n            var aacArray = new Uint8Array(this.data.buffer, this.readOffset, this.unreadLength);\n            var packetType = aacArray[0];\n            this.readOffset += 1;\n            aacData.packetType = packetType;\n            if (!packetType) {\n                var _currentTag = this.currentTag,\n                    position = _currentTag.position,\n                    tagSize = _currentTag.tagSize;\n\n                this._store.metaEndPosition = position + _Buffer2.default.readAsInt(tagSize) + 4;\n                aacData.data = this._parseAACAudioSpecificConfig(); // AAC Sequence header\n            } else {\n                aacData.data = aacArray.slice(1);\n            }\n\n            return aacData;\n        }\n    }, {\n        key: '_parseAACAudioSpecificConfig',\n        value: function _parseAACAudioSpecificConfig() {\n            var dv = new _DataView4Read2.default(this.data.buffer, this);\n            var getAndNum = _DataView4Read2.default.getAndNum;\n\n\n            var resultObj = {\n                samplingFrequency: null,\n                extAudioObjectType: null,\n                extAudioSamplingIdx: null\n            },\n                config = {};\n            var UInt0 = dv.getUint8(),\n                UInt1 = dv.getUint8();\n\n            var tempAudioObjectType = void 0;\n            var audioObjectType = tempAudioObjectType = UInt0 >>> 3; // UInt5\n            var samplingIdx = (UInt0 & getAndNum(5, 7)) << 1 | UInt1 >>> 7; // UInt4\n            if (samplingIdx < 0 || samplingIdx > _types.samplingFrequencyTypes.length) {\n                this.dispatch(_types.EventTypes.ERROR, 'error samplingFrequencyIndex: ' + samplingIdx);\n                return;\n            }\n\n            resultObj.samplingFrequency = _types.samplingFrequencyTypes[samplingIdx];\n\n            var channelCount = resultObj.channelCount = (UInt1 & getAndNum(1, 4)) >>> 3;\n            if (channelCount < 0 || channelCount > 7) {\n                this.dispatch(_types.EventTypes.ERROR, 'error Audio Channel Count: ' + channelCount);\n                return;\n            }\n\n            if (audioObjectType === 5) {\n                // HE-AAC\n                var UInt2 = dv.getUint8();\n                resultObj.extAudioSamplingIdx = (UInt1 & getAndNum(5, 7)) << 1 | UInt2 >>> 7;\n                resultObj.extAudioObjectType = (UInt2 & getAndNum(1, 5)) >>> 2;\n            }\n\n            if (_sniffer2.default.browser === _types.browserTypes.FIRE_FOX) {\n                if (samplingIdx >= 6) {\n                    // HE-AAC uses SBR, high frequencies are constructed from low frequencies\n                    audioObjectType = 5;\n                    config = new Array(4);\n                    resultObj.extAudioSamplingIdx = samplingIdx - 3;\n                } else {\n                    audioObjectType = 2;\n                    config = new Array(2);\n                    resultObj.extAudioSamplingIdx = samplingIdx;\n                }\n            } else if (_sniffer2.default.os.isAndroid) {\n                // Android : always use AAC\n                audioObjectType = 2;\n                config = new Array(2);\n                resultObj.extAudioSamplingIdx = samplingIdx;\n            } else {\n\n                /*  for other browsers (Chrome/Vivaldi/Opera ...)\n                    always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n                */\n                audioObjectType = 5;\n                resultObj.extensionSamplingIndex = samplingIdx;\n                config = new Array(4);\n\n                if (samplingIdx >= 6) {\n                    resultObj.extensionSamplingIdx = samplingIdx - 3;\n                } else if (channelCount === 1) {\n                    audioObjectType = 2;\n                    config = new Array(2);\n                    resultObj.extensionSamplingIndex = samplingIdx;\n                }\n            }\n\n            config[0] = audioObjectType << 3;\n            config[0] |= (samplingIdx & 0x0E) >> 1;\n            config[1] |= (samplingIdx & 0x01) << 7;\n            config[1] |= channelCount << 3;\n            if (audioObjectType === 5) {\n                config[1] |= (resultObj.extAudioSamplingIdx & 0x0E) >> 1;\n                config[2] = (resultObj.extensionSamplingIdx & 0x01) << 7;\n                // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n                //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n                config[2] |= 2 << 2;\n                config[3] = 0;\n            }\n\n            return {\n                config: config,\n                sampleFreq: resultObj.samplingFrequency,\n                channelCount: channelCount,\n                codec: 'mp4a.40.' + audioObjectType,\n                manifestCodec: 'mp4a.40.' + tempAudioObjectType\n            };\n        }\n    }, {\n        key: 'initAudioMeta',\n        value: function initAudioMeta(meta) {\n            var _store = this._store,\n                state = _store.state,\n                track = _store.audioTrack;\n\n\n            meta.duration = state.duration;\n            meta.timeScale = state.timeScale;\n            meta.type = 'audio';\n            meta.id = track.id;\n\n            return meta;\n        }\n    }, {\n        key: 'resetStatus',\n        value: function resetStatus() {\n            this.currentTag = null;\n            this.data = new Uint8Array(0);\n            this.readOffset = 0;\n        }\n    }, {\n        key: 'dataSize',\n        get: function get() {\n            return this.data.length;\n        }\n    }, {\n        key: 'unreadLength',\n        get: function get() {\n            return this.dataSize - this.readOffset;\n        }\n    }]);\n\n    return AudioDemuxer;\n}(_Demuxer3.default);\n\nexports.default = AudioDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/demux/AudioDemuxer.js?");

/***/ }),

/***/ "./src/parse/demux/Demuxer.js":
/*!************************************!*\
  !*** ./src/parse/demux/Demuxer.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Log = __webpack_require__(/*! ../../utils/Log */ \"./src/utils/Log.js\");\n\nvar _Log2 = _interopRequireDefault(_Log);\n\nvar _EventEmitter = __webpack_require__(/*! ../../utils/EventEmitter */ \"./src/utils/EventEmitter.js\");\n\nvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Demuxer = function () {\n    function Demuxer(store) {\n        _classCallCheck(this, Demuxer);\n\n        if (store) {\n            this._store = store;\n        }\n\n        this._emitter = _EventEmitter2.default;\n        this.on = _EventEmitter2.default.on.bind(_EventEmitter2.default);\n        this.once = _EventEmitter2.default.once.bind(_EventEmitter2.default);\n        this.removeListener = _EventEmitter2.default.removeListener.bind(_EventEmitter2.default);\n        this.removeAllListeners = _EventEmitter2.default.removeAllListeners.bind(_EventEmitter2.default);\n        this.emit = _EventEmitter2.default.emit.bind(_EventEmitter2.default);\n    }\n\n    _createClass(Demuxer, [{\n        key: 'dispatch',\n        value: function dispatch(type) {\n            var _emitter;\n\n            var prefix = 'demuxer_';\n\n            for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                payload[_key - 1] = arguments[_key];\n            }\n\n            (_emitter = this._emitter).emit.apply(_emitter, ['' + prefix + type].concat(payload));\n        }\n    }, {\n        key: 'error',\n        value: function error(message) {\n            var _CLASS_NAME = this.CLASS_NAME,\n                CLASS_NAME = _CLASS_NAME === undefined ? 'Demuxer' : _CLASS_NAME;\n\n            _Log2.default.error('[' + CLASS_NAME + ' error] ', message);\n        }\n    }, {\n        key: 'info',\n        value: function info(message) {\n            var _CLASS_NAME2 = this.CLASS_NAME,\n                CLASS_NAME = _CLASS_NAME2 === undefined ? 'Demuxer' : _CLASS_NAME2;\n\n            _Log2.default.info('[' + CLASS_NAME + ' info] ', message);\n        }\n    }, {\n        key: 'log',\n        value: function log(message) {\n            var _CLASS_NAME3 = this.CLASS_NAME,\n                CLASS_NAME = _CLASS_NAME3 === undefined ? 'Demuxer' : _CLASS_NAME3;\n\n            _Log2.default.log('[' + CLASS_NAME + ' log] ', message);\n        }\n    }, {\n        key: 'warn',\n        value: function warn(message) {\n            var _CLASS_NAME4 = this.CLASS_NAME,\n                CLASS_NAME = _CLASS_NAME4 === undefined ? 'Demuxer' : _CLASS_NAME4;\n\n            _Log2.default.warn('[' + CLASS_NAME + ' warn] ', message);\n        }\n    }]);\n\n    return Demuxer;\n}();\n\nexports.default = Demuxer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/demux/Demuxer.js?");

/***/ }),

/***/ "./src/parse/demux/MetaDemuxer.js":
/*!****************************************!*\
  !*** ./src/parse/demux/MetaDemuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _types = __webpack_require__(/*! ../../constants/types */ \"./src/constants/types.js\");\n\nvar _UTF = __webpack_require__(/*! ../../utils/UTF8 */ \"./src/utils/UTF8.js\");\n\nvar _UTF2 = _interopRequireDefault(_UTF);\n\nvar _Demuxer2 = __webpack_require__(/*! ./Demuxer */ \"./src/parse/demux/Demuxer.js\");\n\nvar _Demuxer3 = _interopRequireDefault(_Demuxer2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * meta信息解析\n */\nvar MetaDemuxer = function (_Demuxer) {\n    _inherits(MetaDemuxer, _Demuxer);\n\n    function MetaDemuxer(store) {\n        _classCallCheck(this, MetaDemuxer);\n\n        var _this = _possibleConstructorReturn(this, (MetaDemuxer.__proto__ || Object.getPrototypeOf(MetaDemuxer)).call(this, store));\n\n        _this.offset = 0;\n        _this.readOffset = _this.offset;\n        return _this;\n    }\n\n    _createClass(MetaDemuxer, [{\n        key: 'resolve',\n        value: function resolve(meta, size) {\n            if (size < 3) {\n                throw 'not enough data for metainfo';\n            }\n            var metaData = {};\n            var name = this.parseValue(meta);\n            var value = this.parseValue(meta, size - name.bodySize);\n            metaData[name.data] = value.data;\n\n            this.resetStatus();\n            return metaData;\n        }\n    }, {\n        key: 'resetStatus',\n        value: function resetStatus() {\n            this.offset = 0;\n            this.readOffset = this.offset;\n        }\n    }, {\n        key: 'parseString',\n        value: function parseString(buffer) {\n            var dv = new DataView(buffer, this.readOffset);\n            var strLen = dv.getUint16(0, !this.isLe);\n            var str = '';\n            if (strLen > 0) {\n                str = _UTF2.default.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n            } else {\n                str = '';\n            }\n            var size = strLen + 2;\n            this.readOffset += size;\n            return {\n                data: str,\n                bodySize: strLen + 2\n            };\n        }\n    }, {\n        key: 'parseDate',\n        value: function parseDate(buffer, size) {\n            var isLe = this.isLe;\n\n            var dv = new DataView(buffer, this.readOffset, size);\n            var ts = dv.getFloat64(0, !isLe);\n            var timeOffset = dv.getInt16(8, !isLe);\n            ts += timeOffset * 60 * 1000;\n\n            this.readOffset += 10;\n            return {\n                data: new Date(ts),\n                bodySize: 10\n            };\n        }\n    }, {\n        key: 'parseObject',\n        value: function parseObject(buffer, size) {\n            var name = this.parseString(buffer, size);\n            var value = this.parseValue(buffer, size - name.bodySize);\n            return {\n                data: {\n                    name: name.data,\n                    value: value.data\n                },\n                bodySize: name.bodySize + value.bodySize,\n                isObjEnd: value.isObjEnd\n            };\n        }\n    }, {\n        key: 'parseLongString',\n        value: function parseLongString(buffer) {\n            var dv = new DataView(buffer, this.readOffset);\n            var strLen = dv.getUint32(0, !this.isLe);\n            var str = '';\n            if (strLen > 0) {\n                str = _UTF2.default.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n            } else {\n                str = '';\n            }\n            // const size = strLen + 4;\n            this.readOffset += strLen + 4;\n            return {\n                data: str,\n                bodySize: strLen + 4\n            };\n        }\n\n        /**\n         * 解析meta中的变量\n         */\n\n    }, {\n        key: 'parseValue',\n        value: function parseValue(data, size) {\n            var buffer = new ArrayBuffer();\n            if (data instanceof ArrayBuffer) {\n                buffer = data;\n            } else {\n                buffer = data.buffer;\n            }\n            var isLe = this.isLe;\n            var NUMBER = _types.MetaTypes.NUMBER,\n                BOOLEAN = _types.MetaTypes.BOOLEAN,\n                STRING = _types.MetaTypes.STRING,\n                OBJECT = _types.MetaTypes.OBJECT,\n                MIX_ARRAY = _types.MetaTypes.MIX_ARRAY,\n                OBJECT_END = _types.MetaTypes.OBJECT_END,\n                STRICT_ARRAY = _types.MetaTypes.STRICT_ARRAY,\n                DATE = _types.MetaTypes.DATE,\n                LONE_STRING = _types.MetaTypes.LONE_STRING;\n\n            var dataView = new DataView(buffer, this.readOffset, size);\n            var isObjEnd = false;\n            var type = dataView.getUint8(0);\n            var offset = 1;\n            this.readOffset += 1;\n            var value = null;\n\n            switch (type) {\n                case NUMBER:\n                    {\n                        value = dataView.getFloat64(1, !isLe);\n                        this.readOffset += 8;\n                        offset += 8;\n                        break;\n                    }\n                case BOOLEAN:\n                    {\n                        var boolNum = dataView.getUint8(1);\n                        value = !!boolNum;\n                        this.readOffset += 1;\n                        offset += 1;\n                        break;\n                    }\n                case STRING:\n                    {\n                        var str = this.parseString(buffer);\n                        value = str.data;\n                        offset += str.bodySize;\n                        break;\n                    }\n                case OBJECT:\n                    {\n                        value = {};\n                        var objEndSize = 0;\n                        if (dataView.getUint32(size - 4, !isLe) & 0x00FFFFFF) {\n                            objEndSize = 3;\n                        }\n                        // this.readOffset += offset - 1;\n                        while (offset < size - 4) {\n\n                            var amfObj = this.parseObject(buffer, size - offset - objEndSize);\n                            if (amfObj.isObjectEnd) {\n                                break;\n                            }\n                            value[amfObj.data.name] = amfObj.data.value;\n                            offset += amfObj.bodySize;\n                        }\n                        if (offset <= size - 3) {\n                            var mark = dataView.getUint32(offset - 1, !isLe) & 0x00FFFFFF;\n                            if (mark === 9) {\n                                this.readOffset += 3;\n                                offset += 3;\n                            }\n                        }\n                        break;\n                    }\n                case MIX_ARRAY:\n                    {\n                        value = {};\n                        offset += 4;\n                        this.readOffset += 4;\n                        var _objEndSize = 0;\n                        if ((dataView.getUint32(size - 4, !isLe) & 0x00FFFFFF) === 9) {\n                            _objEndSize = 3;\n                        }\n\n                        while (offset < size - 8) {\n                            var amfVar = this.parseObject(buffer, size - offset - _objEndSize);\n                            if (amfVar.isObjectEnd) {\n                                break;\n                            }\n                            value[amfVar.data.name] = amfVar.data.value;\n                            offset += amfVar.bodySize;\n                        }\n                        if (offset <= size - 3) {\n                            var marker = dataView.getUint32(offset - 1, !isLe) & 0x00FFFFFF;\n                            if (marker === 9) {\n                                offset += 3;\n                                this.readOffset += 3;\n                            }\n                        }\n                        break;\n                    }\n\n                case OBJECT_END:\n                    {\n                        value = null;\n                        isObjEnd = true;\n                        break;\n                    }\n\n                case STRICT_ARRAY:\n                    {\n                        value = [];\n                        var arrLength = dataView.getUint32(1, !isLe);\n                        offset += 4;\n                        this.readOffset += 4;\n                        for (var i = 0; i < arrLength; i++) {\n\n                            var script = this.parseValue(buffer, size - offset);\n                            value.push(script.data);\n                            offset += script.bodySize;\n                        }\n                        break;\n                    }\n\n                case DATE:\n                    {\n                        var date = this.parseDate(buffer, size - 1);\n                        value = date.data;\n                        offset += date.bodySize;\n                        break;\n                    }\n\n                case LONE_STRING:\n                    {\n                        var longStr = this.parseLongString(buffer, size - 1);\n                        value = longStr.data;\n                        offset += longStr.bodySize;\n                        break;\n                    }\n\n                default:\n                    {\n                        offset = size;\n                    }\n            }\n\n            return {\n                data: value,\n                bodySize: offset,\n                isObjEnd: isObjEnd\n            };\n        }\n    }, {\n        key: 'isLe',\n        get: function get() {\n            return this._store.isLe;\n        }\n    }]);\n\n    return MetaDemuxer;\n}(_Demuxer3.default);\n\nexports.default = MetaDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/demux/MetaDemuxer.js?");

/***/ }),

/***/ "./src/parse/demux/TagDemuxer.js":
/*!***************************************!*\
  !*** ./src/parse/demux/TagDemuxer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Demuxer2 = __webpack_require__(/*! ./Demuxer */ \"./src/parse/demux/Demuxer.js\");\n\nvar _Demuxer3 = _interopRequireDefault(_Demuxer2);\n\nvar _MetaDemuxer = __webpack_require__(/*! ./MetaDemuxer */ \"./src/parse/demux/MetaDemuxer.js\");\n\nvar _MetaDemuxer2 = _interopRequireDefault(_MetaDemuxer);\n\nvar _VideoDemuxer = __webpack_require__(/*! ./VideoDemuxer */ \"./src/parse/demux/VideoDemuxer.js\");\n\nvar _VideoDemuxer2 = _interopRequireDefault(_VideoDemuxer);\n\nvar _AudioDemuxer = __webpack_require__(/*! ./AudioDemuxer */ \"./src/parse/demux/AudioDemuxer.js\");\n\nvar _AudioDemuxer2 = _interopRequireDefault(_AudioDemuxer);\n\nvar _Log = __webpack_require__(/*! ../../utils/Log */ \"./src/utils/Log.js\");\n\nvar _Log2 = _interopRequireDefault(_Log);\n\nvar _metaFields = __webpack_require__(/*! ../../constants/metaFields */ \"./src/constants/metaFields.js\");\n\nvar _metaFields2 = _interopRequireDefault(_metaFields);\n\nvar _types = __webpack_require__(/*! ../../constants/types */ \"./src/constants/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar nativeHasProp = Object.prototype.hasOwnProperty;\n\nvar Tagdemux = function (_Demuxer) {\n  _inherits(Tagdemux, _Demuxer);\n\n  function Tagdemux(store) {\n    _classCallCheck(this, Tagdemux);\n\n    var _this = _possibleConstructorReturn(this, (Tagdemux.__proto__ || Object.getPrototypeOf(Tagdemux)).call(this, store));\n\n    _this.CLASS_NAME = _this.constructor.name;\n    _this._metaDemuxer = new _MetaDemuxer2.default(store);\n    _this._videoDemuxer = new _VideoDemuxer2.default(store);\n    _this._audioDemuxer = new _AudioDemuxer2.default(store);\n    _this._firstParse = true;\n    _this._dataOffset = 0;\n    return _this;\n  }\n\n  _createClass(Tagdemux, [{\n    key: 'destroy',\n    value: function destroy() {\n      this._metaDemuxer = null;\n      this._videoDemuxer = null;\n      this._audioDemuxer = null;\n    }\n  }, {\n    key: 'resolveTags',\n    value: function resolveTags() {\n      var _this2 = this;\n\n      var tags = this._store.state.tags;\n      var store = this._store;\n      var videoTrack = store.videoTrack,\n          audioTrack = store.audioTrack;\n\n\n      tags.forEach(function (tag) {\n        _this2.resolveTag(tag);\n      });\n\n      if (this._store.hasInitialMetaDispatched) {\n        if (videoTrack.length || audioTrack.length) {\n          this.dispatch(_types.EventTypes.DATA_READY, audioTrack, videoTrack);\n        }\n      }\n\n      this._store.state.tags = [];\n    }\n  }, {\n    key: 'resolveTag',\n    value: function resolveTag(tag) {\n      switch (String(tag.tagType)) {\n        case '8':\n          // audio\n          this._resolveAudioTag(tag);\n          break;\n        case '9':\n          // video\n          this._resolveVideoTag(tag);\n          break;\n        case '18':\n          // metadata\n          this._resolveMetaTag(tag);\n          break;\n      }\n    }\n  }, {\n    key: '_resolveAudioTag',\n    value: function _resolveAudioTag(tag) {\n      if (tag.bodySize <= 1) {\n        this.warn('Not enough data for audio tag body');\n      }\n      this._audioDemuxer.resolve(tag);\n    }\n  }, {\n    key: '_resolveVideoTag',\n    value: function _resolveVideoTag(tag) {\n      if (tag.bodySize <= 1) {\n        this.error('Not enough data for video tag body');\n        return;\n      }\n      var _hasVideo = this._hasVideo,\n          hasVideoFlagOverrided = this.hasVideoFlagOverrided;\n\n      if (hasVideoFlagOverrided && !_hasVideo) {\n        return;\n      }\n\n      this._videoDemuxer.resolve(tag);\n    }\n  }, {\n    key: '_initMetaData',\n    value: function _initMetaData(metaData) {\n      var _this3 = this;\n\n      var s = this._store;\n\n      if (nativeHasProp.call(metaData, 'onMetaData')) {\n        if (s.hasMetaData) {\n          _Log2.default.log('[' + this.CLASS_NAME + ']', 'found another meta tag');\n        }\n        s.metaData = metaData;\n        var onMetaData = metaData.onMetaData;\n\n        _metaFields2.default.forEach(function (field) {\n          var name = field.name,\n              type = field.type,\n              parser = field.parser,\n              onTypeErr = field.onTypeErr;\n\n          if (Object(onMetaData[name]) instanceof type) {\n            parser.call(_this3, s, onMetaData);\n          } else {\n            if (onTypeErr && onTypeErr instanceof Function) {\n              onTypeErr(s, onMetaData);\n            }\n          }\n        });\n\n        this._store.mediaInfo._metaData = metaData;\n        // 同步到共享store\n        if (this._store.mediaInfo.isComplete) {\n          this.dispatch(_types.EventTypes.MEDIA_INFO_READY, this._store.mediaInfo);\n        }\n      }\n    }\n  }, {\n    key: '_resolveMetaTag',\n    value: function _resolveMetaTag(tag) {\n      var body = tag.body;\n\n      var metaObj = this._metaDemuxer.resolve(body, body.length);\n      this._initMetaData(metaObj);\n    }\n  }, {\n    key: '_parseKeyframes',\n    value: function _parseKeyframes(keyframes) {\n      var times = [],\n          filePositions = [];\n      var _store = this._store,\n          videoTimeScale = _store.videoTimeScale,\n          state = _store.state;\n\n      for (var i = 1; i < keyframes.times.length; i++) {\n        times[times.length] = state.timeStampBase + Math.floor(keyframes.times[i] * videoTimeScale);\n        filePositions[filePositions.length] = keyframes.filepositions[i];\n      }\n\n      return {\n        times: times,\n        filePositions: filePositions\n      };\n    }\n  }]);\n\n  return Tagdemux;\n}(_Demuxer3.default);\n\nexports.default = Tagdemux;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/demux/TagDemuxer.js?");

/***/ }),

/***/ "./src/parse/demux/VideoDemuxer.js":
/*!*****************************************!*\
  !*** ./src/parse/demux/VideoDemuxer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Demuxer2 = __webpack_require__(/*! ./Demuxer */ \"./src/parse/demux/Demuxer.js\");\n\nvar _Demuxer3 = _interopRequireDefault(_Demuxer2);\n\nvar _SPSParser = __webpack_require__(/*! ../SPSParser */ \"./src/parse/SPSParser.js\");\n\nvar _SPSParser2 = _interopRequireDefault(_SPSParser);\n\nvar _DataView4Read = __webpack_require__(/*! ../../utils/DataView4Read */ \"./src/utils/DataView4Read.js\");\n\nvar _DataView4Read2 = _interopRequireDefault(_DataView4Read);\n\nvar _types = __webpack_require__(/*! ../../constants/types */ \"./src/constants/types.js\");\n\nvar _Buffer = __webpack_require__(/*! ../../write/Buffer */ \"./src/write/Buffer.js\");\n\nvar _Buffer2 = _interopRequireDefault(_Buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar VideoDemuxer = function (_Demuxer) {\n    _inherits(VideoDemuxer, _Demuxer);\n\n    function VideoDemuxer(store) {\n        _classCallCheck(this, VideoDemuxer);\n\n        var _this = _possibleConstructorReturn(this, (VideoDemuxer.__proto__ || Object.getPrototypeOf(VideoDemuxer)).call(this, store));\n\n        _this.CLASS_NAME = _this.constructor.name;\n        _this.readOffset = 0;\n        _this.data = new Uint8Array(0);\n        _this.currentTag = null;\n        _this._store.videoMetaData = null;\n        return _this;\n    }\n\n    _createClass(VideoDemuxer, [{\n        key: 'resetStatus',\n        value: function resetStatus() {\n            this.readOffset = 0;\n            this.data = new Uint8Array(0);\n            this.currentTag = null;\n        }\n    }, {\n        key: 'resolve',\n        value: function resolve(tag) {\n            this.data = tag.body;\n            this.currentTag = tag;\n            var firstUI8 = this.readData(1)[0];\n            var frameType = (firstUI8 & 0xF0) >>> 4;\n            var codecId = firstUI8 & 0x0F;\n            if (codecId !== 7) {\n\n                /** 1: JPEG\n                * 2: H263\n                * 3: Screen video\n                * 4: On2 VP6\n                * 5: On2 VP6\n                * 6: Screen videoversion 2\n                * 7: AVC\n                */\n                this.error('unsupported codecId: ' + codecId);\n                return;\n            }\n            this._parseAVCPacket(frameType);\n\n            this.resetStatus();\n        }\n    }, {\n        key: '_parseAVCPacket',\n        value: function _parseAVCPacket(frameType) {\n            if (this.unreadLength < 4) {\n                this.error('Invalid Avc Tag');\n            }\n            var isLe = this._store.isLe;\n            var buffer = this.data.buffer;\n\n            var dv = new DataView(buffer, this.readOffset, this.unreadLength);\n            var packageType = dv.getUint8(0);\n\n            var cpsTime = dv.getUint32(0, !isLe) & 0x00FFFFFF;\n            cpsTime = cpsTime << 8 >> 8;\n            this.readOffset += 4;\n\n            switch (packageType) {\n                case 0:\n                    {\n                        var _currentTag = this.currentTag,\n                            position = _currentTag.position,\n                            tagSize = _currentTag.tagSize;\n\n\n                        this._store.metaEndPosition = position + _Buffer2.default.readAsInt(tagSize) + 4; // 缓存scriptTag结束的位置，replay使用\n                        this._parseAVCDecoderConfigurationRecord();\n                        break;\n                    }\n                case 1:\n                    {\n                        this._parseAVCVideoData(frameType, cpsTime);\n                        break;\n                    }\n                case 2:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        // 报错\n                    }\n            }\n        }\n    }, {\n        key: '_parseAVCDecoderConfigurationRecord',\n        value: function _parseAVCDecoderConfigurationRecord() {\n            if (this.unreadLength < 7) {\n                this.error('Invalid AVCDecoderConfigurationRecord, lack of data!');\n                return;\n            }\n\n            var mi = this._store.mediaInfo;\n            // stash offset&unreadSize before parsing sps&pps\n\n            var tempOffset = this.readOffset;\n            var tempUnreadLength = this.unreadLength;\n\n            var store = this._store;\n\n            var meta = this._store.videoMetaData;\n            var track = this._store.videoTrack;\n            var dv = new _DataView4Read2.default(this.data.buffer, this);\n            if (meta) {\n                if (meta.avcc !== undefined) {\n                    this.error('found another AVCDecoderConfigurationRecord!');\n                }\n            } else {\n                if (!store.state._hasVideo && !store.state.hasVideoFlagOverrided) {\n                    store.state._hasVideo = true;\n                    store._mediaInfo.hasVideo = true;\n                }\n                meta = store.videoMetaData = {};\n                meta.type = 'video';\n                meta.id = track.id;\n                meta.timeScale = store.videoTimeScale;\n                meta.duration = store.state.duration;\n                mi.timescale = store.videoTimeScale;\n            }\n\n            var version = dv.getUint8();\n            var avcProfile = dv.getUint8();\n            dv.getUint8();\n            dv.getUint8();\n            if (version !== 1 || avcProfile === 0) {\n                // 处理错误\n                return;\n            }\n\n            var naluLengthSize = store.state.naluLengthSize = dv.getUint(2, this.readOffset, false) + 1;\n            if (naluLengthSize !== 3 && naluLengthSize !== 4) {\n                // 处理错误\n                return;\n            }\n\n            var spsLength = dv.getUint(5, null, false);\n            if (spsLength === 0) {\n                // 处理错误\n                return;\n            } else if (spsLength > 1) {\n                this.warn('AVCDecoderConfigurationRecord: spsLength > 1');\n            }\n            var sps = void 0;\n            for (var i = 0; i < spsLength; i++) {\n                var len = dv.getUint16();\n\n                if (len === 0) {\n                    continue;\n                }\n                sps = new Uint8Array(this.data.buffer, this.readOffset, len);\n                this.readOffset += len;\n                var spsConfig = _SPSParser2.default.parseSPS(sps);\n\n                if (i !== 0) {\n                    continue;\n                }\n\n                var codecSize = spsConfig.codecSize,\n                    presentSize = spsConfig.presentSize,\n                    profileString = spsConfig.profileString,\n                    levelString = spsConfig.levelString,\n                    chromaFormat = spsConfig.chromaFormat,\n                    pixelRatio = spsConfig.pixelRatio,\n                    frameRate = spsConfig.frameRate,\n                    refFrames = spsConfig.refFrames,\n                    bitDepth = spsConfig.bitDepth;\n\n\n                meta.width = codecSize.width;\n                meta.height = codecSize.height;\n                meta.presentWidth = presentSize.width;\n                meta.presentHeight = presentSize.height;\n\n                meta.profile = profileString;\n                meta.level = levelString;\n                // meta.profileCompatibility = profileCompatibility;\n                // meta.naluLengthSize = naluLengthSize;\n\n                meta.bitDepth = bitDepth;\n                meta.chromaFormat = chromaFormat;\n                meta.pixelRatio = pixelRatio;\n                meta.frameRate = frameRate;\n\n                if (!frameRate.fixed || frameRate.fpsNum === 0 || frameRate.fpsDen === 0) {\n                    meta.frameRate = store.referFrameRate;\n                }\n\n                var _meta$frameRate = meta.frameRate,\n                    fpsDen = _meta$frameRate.fpsDen,\n                    fpsNum = _meta$frameRate.fpsNum;\n\n                meta.refSampleDuration = meta.timeScale * (fpsDen / fpsNum);\n\n                var codecArr = sps.subarray(1, 4);\n                var codecStr = 'avc1.';\n                for (var j = 0; j < 3; j++) {\n                    var hex = codecArr[j].toString(16);\n                    hex = hex.padStart(2, '0');\n                    codecStr += hex;\n                }\n\n                meta.codec = codecStr;\n\n                var _mi = this._store.mediaInfo;\n\n                _mi.width = meta.width;\n                _mi.height = meta.height;\n                _mi.fps = meta.frameRate.fps;\n                _mi.profile = meta.profile;\n                _mi.level = meta.level;\n                _mi.refFrames = refFrames;\n                _mi.pixelRatio = pixelRatio;\n                _mi.videoCodec = codecStr;\n                _mi.chromaFormat = chromaFormat;\n                if (_mi.hasAudio) {\n                    if (_mi.audioCodec) {\n                        _mi.mimeType = 'video/x-flv; codecs=\"' + _mi.videoCodec + ',' + _mi.audioCodec + '\"';\n                        _mi.codec = _mi.mimeType.replace('x-flv', 'mp4');\n                    }\n                } else {\n                    _mi.mimeType = 'video/x-flv; codecs=\"' + _mi.videoCodec + '\"';\n                    _mi.codec = _mi.mimeType.replace('x-flv', 'mp4');\n                }\n\n                if (_mi.isComplete) {\n                    this.dispatch(_types.EventTypes.MEDIA_INFO_READY, _mi);\n                }\n            }\n            var pps = void 0;\n            var ppsCount = dv.getUint8();\n            if (!ppsCount) {\n                this.dispatch(_types.EventTypes.ERROR, 'no pps in AVCDecoderConfigurationRecord');\n                return;\n            } else if (ppsCount > 1) {\n                this.warn('AVCDecoderConfigurationRecord has ppsCount: ' + ppsCount);\n            }\n\n            for (var _i = 0; _i < ppsCount; _i++) {\n                var ppsSize = dv.getUint16();\n\n                if (!ppsSize) {\n                    continue;\n                }\n\n                pps = new Uint8Array(this.data.buffer, this.readOffset, ppsSize);\n                this.readOffset += ppsSize;\n            }\n\n            mi.sps = meta.sps = sps;\n            mi.pps = meta.pps = pps;\n            if (store.hasInitialMetaDispatched) {\n                if (store.videoTrack.length || store.audioTrack.length) {\n                    this.dispatch(_types.EventTypes.DATA_READY, store.videoTrack, store.audioTrack);\n                }\n            } else {\n                store.state._videoInitialMetadataDispatched = true;\n            }\n\n            this.dispatch(_types.EventTypes.META_DATA_READY, 'video', meta);\n        }\n    }, {\n        key: '_parseAVCVideoData',\n        value: function _parseAVCVideoData(frameType, cpsTime) {\n            var dv = new _DataView4Read2.default(this.data.buffer, this);\n\n            var naluList = [],\n                dataLen = 0;\n            var naluLenSize = this._store.state.naluLengthSize;\n\n            var ts = this._store.state.timeStampBase + this.currentTag.getTime();\n            var isKeyframe = frameType === 1;\n            while (this.unreadLength > 0) {\n                if (this.unreadLength < 4) {\n                    this.warn('not enough data for parsing AVC');\n                    break;\n                }\n                var tempReadOffset = this.readOffset;\n                var naluSize = naluLenSize === 4 ? dv.getUint32() : dv.getUint24();\n                if (naluSize > this.unreadLength) {\n                    return;\n                }\n\n                var unitType = dv.getUint(5, this.readOffset, false);\n\n                if (unitType === 5) {\n                    isKeyframe = true;\n                }\n\n                var data = new Uint8Array(this.data.buffer, tempReadOffset, naluLenSize + naluSize);\n                this.readOffset = tempReadOffset + naluLenSize + naluSize;\n                var naluUnit = {\n                    type: unitType,\n                    data: data\n                };\n                naluList.push(naluUnit);\n                dataLen += data.byteLength;\n            }\n            dv = null;\n            if (naluList.length) {\n                var videoTrack = this._store.videoTrack;\n\n                var videoSample = {\n                    units: naluList,\n                    length: dataLen,\n                    dts: ts,\n                    cps: cpsTime,\n                    pts: ts + cpsTime,\n                    isKeyframe: isKeyframe,\n                    position: isKeyframe ? this.currentTag.position : undefined\n                };\n                videoTrack.samples.push(videoSample);\n                videoTrack.length += dataLen;\n            }\n        }\n    }, {\n        key: 'readData',\n        value: function readData(num) {\n            var data = this.data,\n                readOffset = this.readOffset;\n\n            if (this.dataSize > readOffset + num) {\n                this.readOffset += num;\n                return data.slice(readOffset, num);\n            }\n            return [];\n        }\n    }, {\n        key: 'dataSize',\n        get: function get() {\n            return this.data.length;\n        }\n    }, {\n        key: 'unreadLength',\n        get: function get() {\n            return this.dataSize - this.readOffset;\n        }\n    }]);\n\n    return VideoDemuxer;\n}(_Demuxer3.default);\n\nexports.default = VideoDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/demux/VideoDemuxer.js?");

/***/ }),

/***/ "./src/parse/remux/Fmp4.js":
/*!*********************************!*\
  !*** ./src/parse/remux/Fmp4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n// const UINT32_MAX = Math.pow(2, 32) - 1;\n\n\nvar _Buffer = __webpack_require__(/*! ../../write/Buffer */ \"./src/write/Buffer.js\");\n\nvar _Buffer2 = _interopRequireDefault(_Buffer);\n\nvar _funcUtils = __webpack_require__(/*! ../../utils/funcUtils */ \"./src/utils/funcUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FMP4 = function () {\n    function FMP4() {\n        _classCallCheck(this, FMP4);\n    }\n\n    _createClass(FMP4, null, [{\n        key: 'size',\n        value: function size(value) {\n            return _Buffer2.default.writeUint32(value);\n        }\n    }, {\n        key: 'initBox',\n        value: function initBox(size, name) {\n            var buffer = new _Buffer2.default();\n\n            for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                content[_key - 2] = arguments[_key];\n            }\n\n            buffer.write.apply(buffer, [FMP4.size(size), FMP4.type(name)].concat(content));\n            return buffer.buffer;\n        }\n    }, {\n        key: 'extension',\n        value: function extension(version, flag) {\n            return new Uint8Array([version, flag >> 16 & 0xff, flag >> 8 & 0xff, flag & 0xff]);\n        }\n    }, {\n        key: 'ftyp',\n        value: function ftyp() {\n            return FMP4.initBox(24, 'ftyp', new Uint8Array([0x69, 0x73, 0x6F, 0x6D, // isom,\n            0x0, 0x0, 0x00, 0x01, // minor_version: 0x01\n            0x69, 0x73, 0x6F, 0x6D, // isom\n            0x61, 0x76, 0x63, 0x31]) // avc1\n            );\n        }\n    }, {\n        key: 'moov',\n        value: function moov(data) {\n            var size = 8;\n            var mvhd = FMP4.mvhd(data.duration, data.timescale);\n            var trak1 = FMP4.videoTrak(data);\n            var trak2 = FMP4.audioTrak(data);\n            var mvex = FMP4.mvex(data.duration, data.timescale);\n            [mvhd, trak1, trak2, mvex].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'moov', mvhd, trak1, trak2, mvex);\n        }\n    }, {\n        key: 'mvhd',\n        value: function mvhd(duration, timeScale) {\n            var timescale = timeScale || 1000;\n            // duration *= timescale;\n            var bytes = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags     1位的box版本+3位flags   box版本，0或1，一般为0。（以下字节数均按version=0）\n            0x00, 0x00, 0x00, 0x00, // creation_time    创建时间  （相对于UTC时间1904-01-01零点的秒数）\n            0x00, 0x00, 0x00, 0x00, // modification_time   修改时间\n\n            /**\n             * timescale: 4 bytes文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n             */\n            timescale >>> 24 & 0xFF, timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF,\n\n            /**\n             * duration: 4 bytes该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000,\n             * duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70\n             */\n            duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0   推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放\n            /**\n             * PreferredVolume(1.0, 2bytes) + reserved(2bytes)\n             * 与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量\n             */\n            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  reserved: 4 + 4 bytes保留位\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 视频变换矩阵   线性代数\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n            0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre-defined 保留位\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n            0xFF, 0xFF, 0xFF, 0xFF]);\n            return FMP4.initBox(8 + bytes.length, 'mvhd', new Uint8Array(bytes));\n        }\n    }, {\n        key: 'videoTrak',\n        value: function videoTrak(data) {\n            var size = 8;\n            var tkhd = FMP4.tkhd({\n                id: 1,\n                duration: data.duration,\n                timescale: data.timescale,\n                width: data.width,\n                height: data.height,\n                type: 'video'\n            });\n            var mdia = FMP4.mdia({\n                type: 'video',\n                timescale: data.timescale,\n                duration: data.duration,\n                sps: data.sps,\n                pps: data.pps,\n                pixelRatio: data.pixelRatio,\n                width: data.width,\n                height: data.height\n            });\n            [tkhd, mdia].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'trak', tkhd, mdia);\n        }\n    }, {\n        key: 'audioTrak',\n        value: function audioTrak(data) {\n            var size = 8;\n            var tkhd = FMP4.tkhd({\n                id: 2,\n                duration: data.duration,\n                timescale: data.timescale,\n                width: 0,\n                height: 0,\n                type: 'audio'\n            });\n            var mdia = FMP4.mdia({\n                type: 'audio',\n                timescale: data.timescale,\n                duration: data.duration,\n                channelCount: data.audioChannelCount,\n                samplerate: data.audioSampleRate,\n                config: data.audioConfig\n            });\n            [tkhd, mdia].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'trak', tkhd, mdia);\n        }\n    }, {\n        key: 'tkhd',\n        value: function tkhd(data) {\n            var id = data.id,\n                duration = data.duration,\n                width = data.width,\n                height = data.height;\n            var content = new Uint8Array([0x00, 0x00, 0x00, 0x07, // version(0) + flags 1位版本 box版本，0或1，一般为0。（以下字节数均按version=0）按位或操作结果值，预定义如下：\n            // 0x000001 track_enabled，否则该track不被播放；\n            // 0x000002 track_in_movie，表示该track在播放中被引用；\n            // 0x000004 track_in_preview，表示该track在预览时被引用。\n            // 一般该值为7，1+2+4 如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项；对于hint track，该值为0\n            // hint track 这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。\n            0x00, 0x00, 0x00, 0x00, // creation_time创建时间（相对于UTC时间1904-01-01零点的秒数）\n            0x00, 0x00, 0x00, 0x00, // modification time 修改时间\n            id >>> 24 & 0xFF, // track_ID: 4 bytes id号，不能重复且不能为0\n            id >>> 16 & 0xFF, id >>> 8 & 0xFF, id & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes    保留位\n            duration >>> 24 & 0xFF, // duration: 4 bytes track的时间长度\n            duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes    保留位\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)  视频层，默认为0，值小的在上层.track分组信息，默认为0表示该track未与其他track有群组关系\n            0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)    [8.8] 格式，如果为音频track，1.0（0x0100）表示最大音量；否则为0   +保留位\n            0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // 视频变换矩阵\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n            width >>> 8 & 0xFF, // //宽度\n            width & 0xFF, 0x00, 0x00, height >>> 8 & 0xFF, // 高度\n            height & 0xFF, 0x00, 0x00]);\n            return FMP4.initBox(8 + content.byteLength, 'tkhd', content);\n        }\n    }, {\n        key: 'edts',\n        value: function edts(data) {\n            var buffer = new _Buffer2.default(),\n                duration = data.duration,\n                mediaTime = data.mediaTime;\n            buffer.write(FMP4.size(36), FMP4.type('edts'));\n            // elst\n            buffer.write(FMP4.size(28), FMP4.type('elst'));\n            buffer.write(new Uint8Array([0x00, 0x00, 0x00, 0x01, // entry count\n            duration >> 24 & 0xff, duration >> 16 & 0xff, duration >> 8 & 0xff, duration & 0xff, mediaTime >> 24 & 0xff, mediaTime >> 16 & 0xff, mediaTime >> 8 & 0xff, mediaTime & 0xff, 0x00, 0x00, 0x00, 0x01]) // media rate\n            );\n            return buffer.buffer;\n        }\n    }, {\n        key: 'mdia',\n        value: function mdia(data) {\n            var size = 8;\n            var mdhd = FMP4.mdhd(data.timescale, data.duration);\n            var hdlr = FMP4.hdlr(data.type);\n            var minf = FMP4.minf(data);\n            [mdhd, hdlr, minf].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'mdia', mdhd, hdlr, minf);\n        }\n    }, {\n        key: 'mdhd',\n        value: function mdhd(timescale, duration) {\n            var content = new Uint8Array([0x00, 0x00, 0x00, 0x00, // creation_time    创建时间\n            0x00, 0x00, 0x00, 0x00, // modification_time修改时间\n            timescale >>> 24 & 0xFF, // timescale: 4 bytes    文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n            timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF, duration >>> 24 & 0xFF, // duration: 4 bytes  track的时间长度\n            duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x55, 0xC4, // language: und (undetermined) 媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）\n            0x00, 0x00]);\n            return FMP4.initBox(12 + content.byteLength, 'mdhd', FMP4.extension(0, 0), content);\n        }\n    }, {\n        key: 'hdlr',\n        value: function hdlr(type) {\n            var buffer = new _Buffer2.default();\n            var value = [0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00];\n            if (type === 'audio') {\n                value.splice.apply(value, [8, 4].concat([0x73, 0x6f, 0x75, 0x6e]));\n                value.splice.apply(value, [24, 13].concat([0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00]));\n            }\n            return FMP4.initBox(8 + value.length, 'hdlr', new Uint8Array(value));\n        }\n    }, {\n        key: 'minf',\n        value: function minf(data) {\n            var buffer = new _Buffer2.default(),\n                size = 8;\n            var vmhd = data.type === 'video' ? FMP4.vmhd() : FMP4.smhd();\n            var dinf = FMP4.dinf();\n            var stbl = FMP4.stbl(data);\n            [vmhd, dinf, stbl].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'minf', vmhd, dinf, stbl);\n        }\n    }, {\n        key: 'vmhd',\n        value: function vmhd() {\n            return FMP4.initBox(20, 'vmhd', new Uint8Array([0x00, // version\n            0x00, 0x00, 0x01, // flags\n            0x00, 0x00, // graphicsmode\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) // opcolor\n            );\n        }\n    }, {\n        key: 'smhd',\n        value: function smhd() {\n            return FMP4.initBox(16, 'smhd', new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, // balance\n            0x00, 0x00]) // reserved\n            );\n        }\n    }, {\n        key: 'dinf',\n        value: function dinf() {\n            var buffer = new _Buffer2.default();\n            var dref = [0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x01, // entry_count\n            0x00, 0x00, 0x00, 0x0c, // entry_size\n            0x75, 0x72, 0x6c, 0x20, // 'url' type\n            0x00, // version 0\n            0x00, 0x00, 0x01];\n            buffer.write(FMP4.size(36), FMP4.type('dinf'), FMP4.size(28), FMP4.type('dref'), new Uint8Array(dref));\n            return buffer.buffer;\n        }\n    }, {\n        key: 'stbl',\n        value: function stbl(data) {\n            var size = 8;\n            var stsd = FMP4.stsd(data);\n            var stts = FMP4.stts();\n            var stsc = FMP4.stsc();\n            var stsz = FMP4.stsz();\n            var stco = FMP4.stco();\n            [stsd, stts, stsc, stsz, stco].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'stbl', stsd, stts, stsc, stsz, stco);\n        }\n    }, {\n        key: 'stsd',\n        value: function stsd(data) {\n            var content = void 0;\n            if (data.type === 'audio') {\n                // if (!data.isAAC && data.codec === 'mp4') {\n                //     content = FMP4.mp3(data);\n                // } else {\n                //\n                // }\n                // 支持mp4a\n                content = FMP4.mp4a(data);\n            } else {\n                content = FMP4.avc1(data);\n            }\n            return FMP4.initBox(16 + content.byteLength, 'stsd', FMP4.extension(0, 0), new Uint8Array([0x00, 0x00, 0x00, 0x01]), content);\n        }\n    }, {\n        key: 'mp4a',\n        value: function mp4a(data) {\n            var buffer = new _Buffer2.default();\n            var content = new Uint8Array([0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // data_reference_index\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, data.channelCount, // channelcount\n            0x00, 0x10, // sampleSize:16bits\n            0x00, 0x00, 0x00, 0x00, // reserved2\n            data.samplerate >> 8 & 0xff, data.samplerate & 0xff, //\n            0x00, 0x00]);\n            var esds = FMP4.esds(data.config);\n            return FMP4.initBox(8 + content.byteLength + esds.byteLength, 'mp4a', content, esds);\n        }\n    }, {\n        key: 'esds',\n        value: function esds() {\n            var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [43, 146, 8, 0];\n\n            var configlen = config.length;\n            var buffer = new _Buffer2.default();\n            var content = new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n\n            0x03, // descriptor_type\n            0x17 + configlen, // length\n            0x00, 0x01, // es_id\n            0x00, // stream_priority\n\n            0x04, // descriptor_type\n            0x0f + configlen, // length\n            0x40, // codec : mpeg4_audio\n            0x15, // stream_type\n            0x00, 0x00, 0x00, // buffer_size\n            0x00, 0x00, 0x00, 0x00, // maxBitrate\n            0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n            0x05].concat([configlen]).concat(config).concat([0x06, 0x01, 0x02]));\n            buffer.write(FMP4.size(8 + content.byteLength), FMP4.type('esds'), content);\n            return buffer.buffer;\n        }\n    }, {\n        key: 'avc1',\n        value: function avc1(data) {\n            var buffer = new _Buffer2.default(),\n                size = 40; // 8(avc1)+8(avcc)+8(btrt)+16(pasp)\n            var sps = data.sps,\n                pps = data.pps,\n                width = data.width,\n                height = data.height,\n                hSpacing = data.pixelRatio[0],\n                vSpacing = data.pixelRatio[1];\n            var avccBuffer = new _Buffer2.default();\n            avccBuffer.write(new Uint8Array([0x01, // version\n            sps[1], // profile\n            sps[2], // profile compatible\n            sps[3], // level\n            0xfc | 3, 0xE0 | 1].concat([sps.length >>> 8 & 0xff, sps.length & 0xff])));\n            avccBuffer.write(sps, new Uint8Array([1, pps.length >>> 8 & 0xff, pps.length & 0xff]), pps);\n\n            var avcc = avccBuffer.buffer;\n            var avc1 = new Uint8Array([0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // data_reference_index\n            0x00, 0x00, // pre_defined\n            0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n            width >> 8 & 0xff, width & 0xff, // width\n            height >> 8 & 0xff, height & 0xff, // height\n            0x00, 0x48, 0x00, 0x00, // horizresolution\n            0x00, 0x48, 0x00, 0x00, // vertresolution\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // frame_count\n            0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n            0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n            0x00, 0x18, // depth = 24\n            0x11, 0x11]); // pre_defined = -1\n            var btrt = new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n            0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n            0x00, 0x2d, 0xc6, 0xc0]);\n            var pasp = new Uint8Array([hSpacing >> 24, // hSpacing\n            hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n            vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff]);\n\n            buffer.write(FMP4.size(size + avc1.byteLength + avcc.byteLength + btrt.byteLength), FMP4.type('avc1'), avc1, FMP4.size(8 + avcc.byteLength), FMP4.type('avcC'), avcc, FMP4.size(20), FMP4.type('btrt'), btrt, FMP4.size(16), FMP4.type('pasp'), pasp);\n            return buffer.buffer;\n        }\n    }, {\n        key: 'stts',\n        value: function stts() {\n            var content = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00]);\n            return FMP4.initBox(16, 'stts', content);\n        }\n    }, {\n        key: 'stsc',\n        value: function stsc() {\n            var content = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00]);\n            return FMP4.initBox(16, 'stsc', content);\n        }\n    }, {\n        key: 'stco',\n        value: function stco() {\n            var content = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00]);\n            return FMP4.initBox(16, 'stco', content);\n        }\n    }, {\n        key: 'stsz',\n        value: function stsz() {\n            var content = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, // sample_size\n            0x00, 0x00, 0x00, 0x00]);\n            return FMP4.initBox(20, 'stsz', content);\n        }\n    }, {\n        key: 'mvex',\n        value: function mvex(duration) {\n            var buffer = new _Buffer2.default();\n            var mehd = _Buffer2.default.writeUint32(duration);\n            buffer.write(FMP4.size(88), FMP4.type('mvex'), FMP4.size(16), FMP4.type('mehd'), FMP4.extension(0, 0), mehd, FMP4.trex(1), FMP4.trex(2));\n            return buffer.buffer;\n        }\n    }, {\n        key: 'trex',\n        value: function trex(id) {\n            var content = new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n            0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n            0x00, 0x00, 0x00, 0x00, // default_sample_duration\n            0x00, 0x00, 0x00, 0x00, // default_sample_size\n            0x00, 0x01, 0x00, 0x01]);\n            return FMP4.initBox(8 + content.byteLength, 'trex', content);\n        }\n    }, {\n        key: 'moof',\n        value: function moof(data) {\n            var size = 8;\n            var mfhd = FMP4.mfhd();\n            var traf = FMP4.traf(data);\n            [mfhd, traf].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'moof', mfhd, traf);\n        }\n    }, {\n        key: 'mfhd',\n        value: function mfhd() {\n            var content = _Buffer2.default.writeUint32(FMP4.sequence);\n            FMP4.sequence += 1;\n            return FMP4.initBox(16, 'mfhd', FMP4.extension(0, 0), content);\n        }\n    }, {\n        key: 'traf',\n        value: function traf(data) {\n            var size = 8;\n            var tfhd = FMP4.tfhd(data.id);\n            var tfdt = FMP4.tfdt(data.time);\n            var sdtp = FMP4.sdtp(data);\n            var trun = FMP4.trun(data, sdtp.byteLength);\n            [tfhd, tfdt, sdtp, trun].forEach(function (item) {\n                size += item.byteLength;\n            });\n            return FMP4.initBox(size, 'traf', tfhd, tfdt, sdtp, trun);\n        }\n    }, {\n        key: 'tfhd',\n        value: function tfhd(id) {\n            var content = _Buffer2.default.writeUint32(id);\n            return FMP4.initBox(16, 'tfhd', FMP4.extension(0, 0), content);\n        }\n    }, {\n        key: 'tfdt',\n        value: function tfdt(time) {\n            // let upper = Math.floor(time / (UINT32_MAX + 1)),\n            //     lower = Math.floor(time % (UINT32_MAX + 1));\n            return FMP4.initBox(16, 'tfdt', FMP4.extension(0, 0), _Buffer2.default.writeUint32(time));\n        }\n    }, {\n        key: 'trun',\n        value: function trun(data, sdtpLength) {\n            // let id = data.id;\n            // let ceil = id === 1 ? 16 : 12;\n            var buffer = new _Buffer2.default();\n            var sampleCount = _Buffer2.default.writeUint32(data.samples.length);\n            // mdat-header 8\n            // moof-header 8\n            // mfhd 16\n            // traf-header 8\n            // thhd 16\n            // tfdt 20\n            // trun-header 12\n            // sampleCount 4\n            // data-offset 4\n            // samples.length\n            var offset = _Buffer2.default.writeUint32(8 + 8 + 16 + 8 + 16 + 16 + 12 + 4 + 4 + 16 * data.samples.length + sdtpLength);\n            buffer.write(FMP4.size(20 + 16 * data.samples.length), FMP4.type('trun'), new Uint8Array([0x00, 0x00, 0x0F, 0x01]), sampleCount, offset);\n\n            var size = buffer.buffer.byteLength,\n                writeOffset = 0;\n            data.samples.forEach(function () {\n                size += 16;\n            });\n\n            var trunBox = new Uint8Array(size);\n\n            trunBox.set(buffer.buffer, 0);\n            writeOffset += buffer.buffer.byteLength;\n            data.samples.forEach(function (item) {\n\n                trunBox.set(_Buffer2.default.writeUint32(item.duration), writeOffset);\n                writeOffset += 4;\n                trunBox.set(_Buffer2.default.writeUint32(item.size), writeOffset);\n                writeOffset += 4;\n\n                if (data.id === 1) {\n                    trunBox.set(_Buffer2.default.writeUint32(item.isKeyframe ? 0x02000000 : 0x01010000), writeOffset);\n                    writeOffset += 4;\n                    trunBox.set(_Buffer2.default.writeUint32(item.cps), writeOffset);\n                    writeOffset += 4;\n                } else {\n                    trunBox.set(_Buffer2.default.writeUint32(0x01000000), writeOffset);\n                    writeOffset += 4;\n                    trunBox.set(_Buffer2.default.writeUint32(0), writeOffset);\n                    writeOffset += 4;\n                }\n\n                // buffer.write(Buffer.writeUint32(0));\n            });\n            return trunBox;\n        }\n    }, {\n        key: 'sdtp',\n        value: function sdtp(data) {\n            var buffer = new _Buffer2.default();\n            buffer.write(FMP4.size(12 + data.samples.length), FMP4.type('sdtp'), FMP4.extension(0, 0));\n            data.samples.forEach(function (item) {\n                buffer.write(new Uint8Array(data.id === 1 ? [item.key ? 32 : 16] : [16]));\n            });\n            return buffer.buffer;\n        }\n    }, {\n        key: 'mdat',\n        value: function mdat(data) {\n            var buffer = new _Buffer2.default(),\n                size = 8;\n            data.samples.forEach(function (item) {\n                size += item.size;\n            });\n            buffer.write(FMP4.size(size), FMP4.type('mdat'));\n            var mdatBox = new Uint8Array(size);\n            var offset = 0;\n            mdatBox.set(buffer.buffer, offset);\n            offset += 8;\n            data.samples.forEach(function (item) {\n                item.buffer.forEach(function (unit) {\n                    mdatBox.set(unit.data, offset);\n                    offset += unit.data.byteLength;\n                    // buffer.write(unit.data);\n                });\n            });\n            return mdatBox;\n        }\n    }]);\n\n    return FMP4;\n}();\n\nFMP4.type = (0, _funcUtils.cacheWrapper)(function (name) {\n    return new Uint8Array([name.charCodeAt(0), name.charCodeAt(1), name.charCodeAt(2), name.charCodeAt(3)]);\n});\nFMP4.sequence = 1;\n\nexports.default = FMP4;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/remux/Fmp4.js?");

/***/ }),

/***/ "./src/parse/remux/Mp4remux.js":
/*!*************************************!*\
  !*** ./src/parse/remux/Mp4remux.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MediaSegmentList = __webpack_require__(/*! ../../models/MediaSegmentList */ \"./src/models/MediaSegmentList.js\");\n\nvar _MediaSegmentList2 = _interopRequireDefault(_MediaSegmentList);\n\nvar _MediaSegment = __webpack_require__(/*! ../../models/MediaSegment */ \"./src/models/MediaSegment.js\");\n\nvar _MediaSegment2 = _interopRequireDefault(_MediaSegment);\n\nvar _MediaSample = __webpack_require__(/*! ../../models/MediaSample */ \"./src/models/MediaSample.js\");\n\nvar _MediaSample2 = _interopRequireDefault(_MediaSample);\n\nvar _sniffer = __webpack_require__(/*! ../../utils/sniffer */ \"./src/utils/sniffer.js\");\n\nvar _sniffer2 = _interopRequireDefault(_sniffer);\n\nvar _Buffer = __webpack_require__(/*! ../../write/Buffer */ \"./src/write/Buffer.js\");\n\nvar _Buffer2 = _interopRequireDefault(_Buffer);\n\nvar _Fmp = __webpack_require__(/*! ./Fmp4 */ \"./src/parse/remux/Fmp4.js\");\n\nvar _Fmp2 = _interopRequireDefault(_Fmp);\n\nvar _EventEmitter = __webpack_require__(/*! ../../utils/EventEmitter */ \"./src/utils/EventEmitter.js\");\n\nvar _EventEmitter2 = _interopRequireDefault(_EventEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Mp4Remuxer = function () {\n  function Mp4Remuxer() {\n    _classCallCheck(this, Mp4Remuxer);\n\n    this._dtsBase = 0;\n    this.isLive = false;\n    this._isDtsBaseInited = false;\n    this._videoMeta = null;\n    this._audioMeta = null;\n    this._audioNextDts = null;\n    this._videoNextDts = null;\n    this._videoSegmentList = new _MediaSegmentList2.default('video');\n    this._audioSegmentList = new _MediaSegmentList2.default('audio');\n    var browser = _sniffer2.default.browser;\n\n    this._emitter = _EventEmitter2.default;\n    this._fillSilenceFrame = browser === 'ie';\n  }\n\n  _createClass(Mp4Remuxer, [{\n    key: 'destroy',\n    value: function destroy() {\n      this._dtsBase = -1;\n      this._dtsBaseInited = false;\n      this._audioMeta = null;\n      this._videoMeta = null;\n      this._videoNextDts = null;\n      this._audioNextDts = null;\n      this._videoSegmentList.clear();\n      this._audioSegmentList.clear();\n      this._videoSegmentList = null;\n      this._audioSegmentList = null;\n    }\n  }, {\n    key: 'remux',\n    value: function remux(audioTrack, videoTrack) {\n      !this._isDtsBaseInited && this.calcDtsBase(audioTrack, videoTrack);\n\n      this._remuxVideo(videoTrack);\n      this._remuxAudio(audioTrack);\n    }\n  }, {\n    key: 'seek',\n    value: function seek() {\n      this._videoNextDts = null;\n      this._audioNextDts = null;\n      this._videoSegmentList.clear();\n      this._audioSegmentList.clear();\n    }\n  }, {\n    key: 'onMetaDataReady',\n    value: function onMetaDataReady(type, meta) {\n      this['_' + type + 'Meta'] = meta;\n    }\n  }, {\n    key: 'onMediaInfoReady',\n    value: function onMediaInfoReady(mediaInfo) {\n      var ftyp_moov = new _Buffer2.default();\n      var ftyp = _Fmp2.default.ftyp();\n      var moov = _Fmp2.default.moov(mediaInfo);\n      ftyp_moov.write(ftyp, moov);\n      return ftyp_moov.buffer;\n    }\n  }, {\n    key: 'calcDtsBase',\n    value: function calcDtsBase(audioTrack, videoTrack) {\n\n      var audioBase = Infinity,\n          videoBase = Infinity;\n      if (audioTrack.samples && audioTrack.samples.length) {\n        audioBase = audioTrack.samples[0].dts;\n      }\n      if (videoTrack.samples && videoTrack.samples.length) {\n        videoBase = videoTrack.samples[0].dts;\n      }\n\n      this._dtsBase = Math.min(audioBase, videoBase);\n      this._isDtsBaseInited = true;\n    }\n  }, {\n    key: '_remuxVideo',\n    value: function _remuxVideo(videoTrack) {\n      if (!this._videoMeta) {\n        return;\n      }\n      var track = videoTrack;\n      if (!videoTrack.samples || !videoTrack.samples.length) {\n        return;\n      }\n      var samples = track.samples,\n          dtsCorrection = void 0,\n          firstDts = -1,\n          lastDts = -1,\n          firstPts = -1,\n          lastPts = -1;\n\n      var mp4Samples = [];\n      var mdatBox = {\n        samples: []\n      };\n      var videoSegment = new _MediaSegment2.default();\n      while (samples.length) {\n        var avcSample = samples.shift();\n        var isKeyframe = avcSample.isKeyframe,\n            cps = avcSample.cps;\n\n        var dts = avcSample.dts - this._dtsBase;\n\n        if (dtsCorrection === undefined) {\n          if (!this._videoNextDts) {\n            var lastSegment = this._videoSegmentList.getLastSegmentBefore(dts);\n            if (lastSegment) {\n              var gap = void 0;\n              var _lastDts = lastSegment.lastDts,\n                  lastGap = lastSegment.gap;\n\n              gap = dts - (_lastDts + lastGap) > 3 ? dts - (_lastDts + lastGap) : 0;\n              dtsCorrection = dts - (_lastDts + gap);\n            } else {\n              dtsCorrection = 0;\n            }\n          } else {\n            dtsCorrection = dts - this._videoNextDts >= 1000 ? 0 : dts - this._videoNextDts;\n          }\n        }\n        var originDts = dts;\n        dts -= dtsCorrection;\n        var pts = dts + cps;\n\n        if (firstDts === -1) {\n          firstDts = dts;\n          firstPts = pts;\n        }\n        var _units = [];\n        while (avcSample.units.length) {\n          var mdatSample = {\n            buffer: [],\n            size: 0\n          };\n          var unit = avcSample.units.shift();\n          _units.push(unit);\n          mdatSample.buffer.push(unit);\n          mdatSample.size += unit.data.byteLength;\n\n          mdatBox.samples.push(mdatSample);\n        }\n\n        var sampleDuration = 0;\n\n        if (samples.length >= 1) {\n          var nextDts = samples[0].dts - this._dtsBase - dtsCorrection;\n          sampleDuration = nextDts - dts;\n        } else {\n          if (mp4Samples.length >= 1) {\n            // lastest sample, use second last duration\n            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n          } else {\n            // the only one sample, use reference duration\n            sampleDuration = this._videoMeta.refSampleDuration;\n          }\n        }\n\n        if (isKeyframe) {\n          var rap = new _MediaSample2.default({\n            dts: dts,\n            pts: pts,\n            duration: sampleDuration,\n            originDts: avcSample.dts,\n            position: avcSample.position,\n            isRAP: true\n          });\n          videoSegment.addRAP(rap);\n        }\n\n        mp4Samples.push({\n          dts: dts,\n          cps: cps,\n          pts: pts,\n          units: _units,\n          size: avcSample.length,\n          isKeyframe: isKeyframe,\n          duration: sampleDuration,\n          originDts: originDts\n        });\n      }\n      var first = mp4Samples[0],\n          last = mp4Samples[mp4Samples.length - 1];\n      lastDts = last.dts + last.duration;\n      lastPts = last.pts + last.duration;\n\n      this._videoNextDts = lastDts;\n\n      videoSegment.startDts = firstDts;\n      videoSegment.endDts = lastDts;\n      videoSegment.startPts = firstPts;\n      videoSegment.endPts = lastPts;\n      videoSegment.originStartDts = first.originDts;\n      videoSegment.originEndDts = last.originDts + last.duration;\n      videoSegment.gap = dtsCorrection;\n      var firstSample = new _MediaSample2.default({\n        dts: first.dts,\n        pts: first.pts,\n        duration: first.duration,\n        isKeyframe: first.isKeyframe,\n        originDts: first.originDts\n      });\n      var lastSample = new _MediaSample2.default({\n        dts: last.dts,\n        pts: last.pts,\n        duration: last.duration,\n        isKeyframe: last.isKeyframe,\n        originDts: last.originDts\n      });\n      videoSegment.firstSample = firstSample;\n      videoSegment.lastSample = lastSample;\n      var moof_mdat = new _Buffer2.default();\n\n      track.samples = mp4Samples;\n      track.time = firstDts;\n      var moof = _Fmp2.default.moof(track);\n      var mdat = _Fmp2.default.mdat(mdatBox);\n      moof_mdat.write(moof, mdat);\n\n      if (!this.isLive) {\n        this._videoSegmentList.append(videoSegment);\n      }\n\n      track.samples = [];\n      track.length = 0;\n\n      this._emitter.emit('mediaFragment', {\n        type: 'video',\n        data: moof_mdat.buffer.buffer,\n        sampleCount: mp4Samples.length,\n        fragment: videoSegment\n      });\n    }\n  }, {\n    key: '_remuxAudio',\n    value: function _remuxAudio(track) {\n\n      if (!this._audioMeta) {\n        return;\n      }\n      var samples = track.samples;\n\n      var dtsCorrection = void 0,\n          firstDts = -1,\n          lastDts = -1,\n          firstPts = -1,\n          lastPts = -1,\n          silentDuration = void 0,\n          mp4Samples = [];\n\n      var mdatBox = {\n        samples: []\n      };\n      if (!samples || !samples.length) {\n        return;\n      }\n      var isFirstDtsInited = false;\n      while (samples.length) {\n        var sample = samples.shift();\n        var unit = sample.unit;\n\n        var dts = sample.dts - this._dtsBase;\n\n        var needSilentFrame = false;\n        if (dtsCorrection === undefined) {\n          if (!this._audioNextDts) {\n\n            var lastSegment = this._audioSegmentList.getLastSegmentBefore(dts);\n            if (lastSegment) {\n              var gap = void 0;\n              var _lastDts2 = lastSegment.lastDts,\n                  lastGap = lastSegment.gap;\n\n              gap = dts - (_lastDts2 + lastGap) > 3 ? dts - (_lastDts2 + lastGap) : 0;\n              dtsCorrection = dts - (_lastDts2 + gap);\n            } else {\n              needSilentFrame = this._fillSilenceFrame && !this._videoSegmentList.isEmpty();\n              dtsCorrection = 0;\n            }\n          } else {\n            dtsCorrection = dts - this._audioNextDts >= 1000 ? 0 : dts - this._audioNextDts;\n          }\n        }\n        var originDts = dts;\n        dts -= dtsCorrection;\n\n        if (needSilentFrame) {\n          var videoSegment = this._videoSegmentList.getLastSampleBefore(originDts);\n\n          if (videoSegment && videoSegment.startDts < dts) {\n            silentDuration = dts - videoSegment.startDts;\n            dts = videoSegment.startDts;\n          } else {\n            needSilentFrame = false;\n          }\n        }\n\n        if (!isFirstDtsInited) {\n          firstDts = dts;\n          isFirstDtsInited = true;\n        }\n\n        if (needSilentFrame) {\n          samples.unshift(sample);\n          var silentFrame = this.initSilentAudio(dts, silentDuration);\n          mp4Samples.push(silentFrame);\n\n          var _mdatSample = {\n            buffer: [],\n            size: 0\n          };\n          _mdatSample.buffer.push({\n            data: silentFrame.unit\n          });\n          _mdatSample.size += silentFrame.unit.byteLength;\n\n          mdatBox.samples.push(_mdatSample);\n          continue;\n        }\n\n        var sampleDuration = 0;\n\n        if (samples.length >= 1) {\n          var nextDts = samples[0].dts - this._dtsBase - dtsCorrection;\n          sampleDuration = nextDts - dts;\n        } else {\n          if (mp4Samples.length >= 1) {\n            // use second last sample duration\n            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n          } else {\n            // the only one sample, use reference sample duration\n            sampleDuration = this._audioMeta.refSampleDuration;\n          }\n        }\n\n        var mp4Sample = {\n          dts: dts,\n          pts: dts,\n          cts: 0,\n          size: unit.byteLength,\n          duration: sampleDuration,\n          originDts: originDts\n        };\n\n        var mdatSample = {\n          buffer: [],\n          size: 0\n        };\n        mdatSample.buffer.push({\n          data: unit\n        });\n        mdatSample.size += unit.byteLength;\n\n        mdatBox.samples.push(mdatSample);\n\n        mp4Samples.push(mp4Sample);\n      }\n\n      var last = mp4Samples[mp4Samples.length - 1];\n      lastDts = last.dts + last.duration;\n\n      this._audioNextDts = lastDts;\n\n      var audioSegment = new _MediaSegment2.default();\n      audioSegment.startDts = firstDts;\n      audioSegment.endDts = lastDts;\n      audioSegment.startPts = firstDts;\n      audioSegment.endPts = lastDts;\n      audioSegment.originStartDts = mp4Samples[0].originDts;\n      audioSegment.originEndDts = last.originDts + last.duration;\n      audioSegment.gap = dtsCorrection;\n      audioSegment.firstSample = new _MediaSample2.default({\n        dts: mp4Samples[0].dts,\n        pts: mp4Samples[0].pts,\n        duration: mp4Samples[0].duration,\n        originDts: mp4Samples[0].originDts\n      });\n      audioSegment.lastSample = new _MediaSample2.default({\n        dts: last.dts,\n        pts: last.pts,\n        duration: last.duration,\n        originDts: last.originDts\n      });\n\n      track.samples = mp4Samples;\n      var moof_mdat = new _Buffer2.default();\n      track.time = firstDts;\n      var moof = _Fmp2.default.moof(track, firstDts);\n      var mdat = _Fmp2.default.mdat(mdatBox);\n      moof_mdat.write(moof, mdat);\n\n      if (!this.isLive) {\n        this._audioSegmentList.append(audioSegment);\n      }\n      track.samples = [];\n      track.length = 0;\n      this._emitter.emit('mediaFragment', {\n        type: 'audio',\n        data: moof_mdat.buffer.buffer,\n        sampleCount: mp4Samples.length,\n        fragment: audioSegment\n      });\n    }\n  }, {\n    key: 'initSilentAudio',\n    value: function initSilentAudio(dts, duration) {\n      var unit = Mp4Remuxer.getSilentFrame(this._audioMeta.channelCount);\n      return {\n        dts: dts,\n        pts: dts,\n        cps: 0,\n        duration: duration,\n        unit: unit,\n        size: unit.byteLength,\n        originDts: dts\n      };\n    }\n  }], [{\n    key: 'getSilentFrame',\n    value: function getSilentFrame(channelCount) {\n      if (channelCount === 1) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n      } else if (channelCount === 2) {\n        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n      } else if (channelCount === 3) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n      } else if (channelCount === 4) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n      } else if (channelCount === 5) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n      } else if (channelCount === 6) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n      }\n      return null;\n    }\n  }]);\n\n  return Mp4Remuxer;\n}();\n\nexports.default = Mp4Remuxer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/parse/remux/Mp4remux.js?");

/***/ }),

/***/ "./src/tasks/LiveTask.js":
/*!*******************************!*\
  !*** ./src/tasks/LiveTask.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LiveTask = function () {\n    function LiveTask(url, config) {\n        _classCallCheck(this, LiveTask);\n\n        var _headers = new window.Headers();\n        var _config = {\n            headers: Object.assign({}, _headers),\n            method: 'GET',\n            cache: 'default',\n            mode: 'cors'\n        };\n        this.request = new Request(url, Object.assign({}, _config, config));\n    }\n\n    _createClass(LiveTask, [{\n        key: 'run',\n        value: function run(callback) {\n\n            function resolve(reader) {\n                reader.read().then(function (result) {\n                    callback(result.done ? undefined : result.value);\n                    resolve(reader);\n                });\n            }\n            fetch(this.request).then(function (res) {\n                var reader = res.body.getReader();\n                resolve(reader);\n            });\n        }\n    }]);\n\n    return LiveTask;\n}();\n\nexports.default = LiveTask;\n\n//# sourceURL=webpack://xgplayer-flv/./src/tasks/LiveTask.js?");

/***/ }),

/***/ "./src/tasks/VodTask.js":
/*!******************************!*\
  !*** ./src/tasks/VodTask.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _XHRLoader = __webpack_require__(/*! ./loaders/XHRLoader */ \"./src/tasks/loaders/XHRLoader.js\");\n\nvar _XHRLoader2 = _interopRequireDefault(_XHRLoader);\n\nvar _FetchLoader = __webpack_require__(/*! ./loaders/FetchLoader */ \"./src/tasks/loaders/FetchLoader.js\");\n\nvar _FetchLoader2 = _interopRequireDefault(_FetchLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LoadCls = function (window) {\n  if (window.fetch) {\n    return _FetchLoader2.default;\n  }\n  return _XHRLoader2.default;\n}(window);\n\nvar VodTask = function () {\n  function VodTask(url, range, headers) {\n    _classCallCheck(this, VodTask);\n\n    this.url = url;\n    this.range = range;\n    this.id = range.join('-');\n    this.on = false;\n    this.loader = new LoadCls(url, range, headers);\n    this.isCanceled = false;\n    VodTask.queue.push(this);\n    VodTask.update();\n  }\n\n  _createClass(VodTask, [{\n    key: 'cancel',\n    value: function cancel() {\n      this.isCanceled = true;\n      this.loader.cancel();\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      if (this.loader.readyState === 1) {\n        this.on = true;\n        this.loader.run();\n      } else {\n        VodTask.remove();\n      }\n    }\n  }, {\n    key: 'promise',\n    get: function get() {\n      return this.loader.promise;\n    }\n  }, {\n    key: 'timeStamp',\n    get: function get() {\n      return this.loader.timeStamp;\n    }\n  }], [{\n    key: 'remove',\n    value: function remove(loader) {\n      VodTask.queue.filter(function (item, idx) {\n        if (item.url === loader.url && item.id === loader.id) {\n          VodTask.queue.splice(idx, 1);\n          return true;\n        } else {\n          return false;\n        }\n      });\n      VodTask.update();\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var Queue = VodTask.queue;\n      var sended = Queue.filter(function (item) {\n        return item.on;\n      });\n      var wait = Queue.filter(function (item) {\n        return !item.on;\n      });\n      var max = VodTask.limit - sended.length;\n      wait.forEach(function (item, idx) {\n        if (idx < max) {\n          item.run();\n        }\n      });\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      VodTask.queue.forEach(function (item) {\n        if (!item.loader.complete) {\n          item.cancel();\n        }\n      });\n      VodTask.queue.length = 0;\n    }\n  }]);\n\n  return VodTask;\n}();\n\nVodTask.queue = [];\nVodTask.limit = 2;\nwindow.VodTask = VodTask;\n\nexports.default = VodTask;\n\n//# sourceURL=webpack://xgplayer-flv/./src/tasks/VodTask.js?");

/***/ }),

/***/ "./src/tasks/loaders/FetchLoader.js":
/*!******************************************!*\
  !*** ./src/tasks/loaders/FetchLoader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _VodTask = __webpack_require__(/*! ../VodTask */ \"./src/tasks/VodTask.js\");\n\nvar _VodTask2 = _interopRequireDefault(_VodTask);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FetchLoader = function () {\n  function FetchLoader(url, range) {\n    var _this = this;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, FetchLoader);\n\n    this.url = url;\n    this.on = false;\n    this.complete = false;\n    this.isStopped = false;\n    this.timeStamp = Date.now();\n    var _config = {\n      headers: {\n        Range: 'bytes=' + range[0] + '-' + range[1]\n      },\n      method: 'GET',\n      cache: 'default',\n      mode: 'cors'\n    };\n\n    this.request = function () {\n      _this.on = true;\n      return window.fetch(url, Object.assign({}, _config, config)).then(function (res) {\n        return res.arrayBuffer();\n      }).then(function (buffer) {\n        _this.complete = true;\n        _this.byteLength = buffer.byteLength;\n        _VodTask2.default.remove(_this);\n        if (_this.isStopped) return {};\n        return {\n          buffer: buffer,\n          timeStamp: _this.timeStamp\n        };\n      }).catch(function (e) {\n        _this.complete = true;\n        _VodTask2.default.remove(_this);\n        return e;\n      });\n    };\n  }\n\n  _createClass(FetchLoader, [{\n    key: 'run',\n    value: function run() {\n      this._promise = this.request();\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      this.isStopped = true;\n    }\n  }, {\n    key: 'readyState',\n    get: function get() {\n      return 1;\n    }\n  }, {\n    key: 'promise',\n    get: function get() {\n      return this.on ? this._promise : this.request();\n    }\n  }]);\n\n  return FetchLoader;\n}();\n\nexports.default = FetchLoader;\n\n//# sourceURL=webpack://xgplayer-flv/./src/tasks/loaders/FetchLoader.js?");

/***/ }),

/***/ "./src/tasks/loaders/XHRLoader.js":
/*!****************************************!*\
  !*** ./src/tasks/loaders/XHRLoader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _VodTask = __webpack_require__(/*! ../VodTask */ \"./src/tasks/VodTask.js\");\n\nvar _VodTask2 = _interopRequireDefault(_VodTask);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XHRLoader = function () {\n    function XHRLoader(url, range) {\n        var _this = this;\n\n        _classCallCheck(this, XHRLoader);\n\n        this.url = url;\n        var xhr = new XMLHttpRequest();\n        xhr.open('get', url);\n        xhr.responseType = 'arraybuffer';\n        xhr.setRequestHeader('Range', 'bytes=' + range[0] + '-' + range[1]);\n        xhr.onabort = function () {\n            _VodTask2.default.remove(_this);\n        };\n        this._promise = new Promise(function (resolve, reject) {\n            xhr.onload = function () {\n                if (xhr.status === 200 || xhr.status === 206) {\n                    resolve(xhr.response);\n                }\n                _VodTask2.default.remove(this);\n            };\n            xhr.onerror = function (e) {\n                reject(e);\n                _VodTask2.default.remove(_this);\n            };\n        });\n\n        this._xhr = xhr;\n    }\n\n    _createClass(XHRLoader, [{\n        key: 'run',\n        value: function run() {\n            this._xhr.send();\n        }\n    }, {\n        key: 'cancel',\n        value: function cancel() {\n            this._xhr.abort();\n        }\n    }, {\n        key: 'promise',\n        get: function get() {\n            return this._promise;\n        }\n    }, {\n        key: 'readyState',\n        get: function get() {\n            return this._xhr.readyState;\n        }\n    }]);\n\n    return XHRLoader;\n}();\n\nexports.default = XHRLoader;\n\n//# sourceURL=webpack://xgplayer-flv/./src/tasks/loaders/XHRLoader.js?");

/***/ }),

/***/ "./src/utils/DataView4Read.js":
/*!************************************!*\
  !*** ./src/utils/DataView4Read.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DataView4Read = function () {\n    function DataView4Read(buffer, context) {\n        _classCallCheck(this, DataView4Read);\n\n        this._dv = new DataView(buffer);\n        this._context = context;\n        this.initProxy();\n    }\n\n    _createClass(DataView4Read, [{\n        key: 'initProxy',\n        value: function initProxy() {\n            var _this = this;\n\n            var sizeArr = [8, 16, 32];\n            var self = this;\n            var _store = this._context._store;\n\n            sizeArr.forEach(function (size) {\n                _this['getUint' + size] = function (offset) {\n                    if (!offset) {\n                        offset = self._context.readOffset;\n                    }\n                    if (offset === self._context.readOffset) {\n                        self._context.readOffset += size / 8;\n                    }\n                    return self._dv['getUint' + size](offset, !_store.isLe);\n                };\n            });\n\n            /**\n             * 显式声明一个比其它位数更常用读取24位整数方法\n             * @param offset\n             * @param isHigh\n             */\n            this.getUint24 = function (offset) {\n                var result = this.getUint(24, offset, false); // 会读取Uint32,做 and 操作之后回退一位。\n                self._context.readOffset -= 1;\n                return result;\n            };\n\n            this.getUint = function (size, offset) {\n                var isHigh = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n                if (size > 32) {\n                    throw 'not supported read size';\n                }\n                var readSize = 32;\n                if (!this['getUint' + size]) {\n                    for (var i = 0, len = sizeArr.length; i < len; i++) {\n                        if (size < sizeArr[i]) {\n                            readSize = sizeArr[i];\n                            break;\n                        }\n                    }\n\n                    var numToAnd = isHigh ? DataView4Read.getAndNum(0, size - 1, readSize) : DataView4Read.getAndNum(readSize - size, readSize - 1, readSize);\n                    return self['getUint' + readSize](offset, !_store.isLe) & numToAnd;\n                } else {\n                    return self['getUint' + readSize](offset, !_store.isLe);\n                }\n            };\n        }\n    }], [{\n        key: 'getAndNum',\n        value: function getAndNum(begin, end) {\n            var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n\n            var result = 0;\n            var index = --size;\n            while (index > 0) {\n                if (index > end || index < begin) {\n                    index--;\n                    continue;\n                } else {\n                    result += Math.pow(2, size - index);\n                    index--;\n                }\n            }\n\n            return result;\n        }\n    }]);\n\n    return DataView4Read;\n}();\n\nexports.default = DataView4Read;\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/DataView4Read.js?");

/***/ }),

/***/ "./src/utils/EventEmitter.js":
/*!***********************************!*\
  !*** ./src/utils/EventEmitter.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar events = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\");\n\nexports.default = new events.EventEmitter();\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/EventEmitter.js?");

/***/ }),

/***/ "./src/utils/ExpGolomb.js":
/*!********************************!*\
  !*** ./src/utils/ExpGolomb.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Log = __webpack_require__(/*! ./Log */ \"./src/utils/Log.js\");\n\nvar _Log2 = _interopRequireDefault(_Log);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ExpGolomb = function () {\n    function ExpGolomb(data) {\n        _classCallCheck(this, ExpGolomb);\n\n        this.data = data;\n        // the number of bytes left to examine in this.data\n        this.bytesAvailable = data.byteLength;\n        // the current word being examined\n        this.word = 0; // :uint\n        // the number of bits left to examine in the current word\n        this.bitsAvailable = 0; // :uint\n    }\n    // ():void\n\n\n    _createClass(ExpGolomb, [{\n        key: 'loadWord',\n        value: function loadWord() {\n            var data = this.data,\n                bytesAvailable = this.bytesAvailable,\n                position = data.byteLength - bytesAvailable,\n                workingBytes = new Uint8Array(4),\n                availableBytes = Math.min(4, bytesAvailable);\n            if (availableBytes === 0) {\n                throw new Error('no bytes available');\n            }\n            workingBytes.set(data.subarray(position, position + availableBytes));\n            this.word = new DataView(workingBytes.buffer).getUint32(0);\n            // track the amount of this.data that has been processed\n            this.bitsAvailable = availableBytes * 8;\n            this.bytesAvailable -= availableBytes;\n        }\n\n        // (count:int):void\n\n    }, {\n        key: 'skipBits',\n        value: function skipBits(count) {\n            var skipBytes; // :int\n            if (this.bitsAvailable > count) {\n                this.word <<= count;\n                this.bitsAvailable -= count;\n            } else {\n                count -= this.bitsAvailable;\n                skipBytes = count >> 3;\n                count -= skipBytes >> 3;\n                this.bytesAvailable -= skipBytes;\n                this.loadWord();\n                this.word <<= count;\n                this.bitsAvailable -= count;\n            }\n            return skipBytes;\n        }\n\n        // (size:int):uint\n\n    }, {\n        key: 'readBits',\n        value: function readBits(size) {\n            var bits = Math.min(this.bitsAvailable, size),\n                // :uint\n            valu = this.word >>> 32 - bits; // :uint\n            if (size > 32) {\n                _Log2.default.error('Cannot read more than 32 bits at a time');\n            }\n            this.bitsAvailable -= bits;\n            if (this.bitsAvailable > 0) {\n                this.word <<= bits;\n            } else if (this.bytesAvailable > 0) {\n                this.loadWord();\n            }\n            bits = size - bits;\n            if (bits > 0 && this.bitsAvailable) {\n                return valu << bits | this.readBits(bits);\n            } else {\n                return valu;\n            }\n        }\n\n        // ():uint\n\n    }, {\n        key: 'skipLZ',\n        value: function skipLZ() {\n            var leadingZeroCount; // :uint\n            for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n                if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {\n                    // the first bit of working word is 1\n                    this.word <<= leadingZeroCount;\n                    this.bitsAvailable -= leadingZeroCount;\n                    return leadingZeroCount;\n                }\n            }\n            // we exhausted word and still have not found a 1\n            this.loadWord();\n            return leadingZeroCount + this.skipLZ();\n        }\n\n        // ():void\n\n    }, {\n        key: 'skipUEG',\n        value: function skipUEG() {\n            this.skipBits(1 + this.skipLZ());\n        }\n\n        // ():void\n\n    }, {\n        key: 'skipEG',\n        value: function skipEG() {\n            this.skipBits(1 + this.skipLZ());\n        }\n\n        // ():uint\n\n    }, {\n        key: 'readUEG',\n        value: function readUEG() {\n            var clz = this.skipLZ(); // :uint\n            return this.readBits(clz + 1) - 1;\n        }\n\n        // ():int\n\n    }, {\n        key: 'readEG',\n        value: function readEG() {\n            var valu = this.readUEG(); // :int\n            if (0x01 & valu) {\n                // the number is odd if the low order bit is set\n                return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n            } else {\n                return -1 * (valu >>> 1); // divide by two then make it negative\n            }\n        }\n\n        // Some convenience functions\n        // :Boolean\n\n    }, {\n        key: 'readBoolean',\n        value: function readBoolean() {\n            return 1 === this.readBits(1);\n        }\n\n        // ():int\n\n    }, {\n        key: 'readUByte',\n        value: function readUByte() {\n            return this.readBits(8);\n        }\n\n        // ():int\n\n    }, {\n        key: 'readUShort',\n        value: function readUShort() {\n            return this.readBits(16);\n        }\n        // ():int\n\n    }, {\n        key: 'readUInt',\n        value: function readUInt() {\n            return this.readBits(32);\n        }\n\n        /**\n         * Advance the ExpGolomb decoder past a scaling list. The scaling\n         * list is optionally transmitted as part of a sequence parameter\n         * set and is not relevant to transmuxing.\n         * @param count {number} the number of entries in this scaling list\n         * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n         */\n\n    }, {\n        key: 'skipScalingList',\n        value: function skipScalingList(count) {\n            var lastScale = 8,\n                nextScale = 8,\n                j,\n                deltaScale;\n            for (j = 0; j < count; j++) {\n                if (nextScale !== 0) {\n                    deltaScale = this.readEG();\n                    nextScale = (lastScale + deltaScale + 256) % 256;\n                }\n                lastScale = nextScale === 0 ? lastScale : nextScale;\n            }\n        }\n\n        /**\n         * Read a sequence parameter set and return some interesting video\n         * properties. A sequence parameter set is the H264 metadata that\n         * describes the properties of upcoming video frames.\n         * @param data {Uint8Array} the bytes of a sequence parameter set\n         * @return {object} an object with configuration parsed from the\n         * sequence parameter set, including the dimensions of the\n         * associated video frames.\n         */\n\n    }, {\n        key: 'readSPS',\n        value: function readSPS() {\n            var frameCropLeftOffset = 0,\n                frameCropRightOffset = 0,\n                frameCropTopOffset = 0,\n                frameCropBottomOffset = 0,\n                profileIdc,\n\n            // profileCompat,\n            levelIdc,\n                codecWidth,\n                codecHeight,\n                presentWidth,\n                numRefFramesInPicOrderCntCycle,\n                picWidthInMbsMinus1,\n                picHeightInMapUnitsMinus1,\n                frameMbsOnlyFlag,\n                scalingListCount,\n                i,\n                readUByte = this.readUByte.bind(this),\n                readBits = this.readBits.bind(this),\n                readUEG = this.readUEG.bind(this),\n                readBoolean = this.readBoolean.bind(this),\n                skipBits = this.skipBits.bind(this),\n                skipEG = this.skipEG.bind(this),\n                skipUEG = this.skipUEG.bind(this),\n                skipScalingList = this.skipScalingList.bind(this);\n\n            readUByte();\n            profileIdc = readUByte(); // profile_idc\n            readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n            skipBits(3); // reserved_zero_3bits u(3),\n            levelIdc = readUByte(); // level_idc u(8)\n            skipUEG(); // seq_parameter_set_id\n            var chromaFormatIdc = 1;\n            var chromaFormat = 420;\n            var chromaFormats = [0, 420, 422, 444];\n            var bitDepthLuma = 8;\n            var profileIdcs = [100, 110, 122, 244, 44, 83, 86, 118, 128];\n            // some profiles have more optional data we don't need\n            if (profileIdcs.includes(profileIdc)) {\n                chromaFormatIdc = readUEG();\n                if (chromaFormatIdc === 3) {\n                    skipBits(1); // separate_colour_plane_flag\n                }\n                if (chromaFormatIdc <= 3) {\n                    chromaFormat = chromaFormats[chromaFormatIdc];\n                }\n                bitDepthLuma = readUEG() + 8; // bit_depth_luma_minus8\n                skipUEG(); // bit_depth_chroma_minus8\n                skipBits(1); // qpprime_y_zero_transform_bypass_flag\n                if (readBoolean()) {\n                    // seq_scaling_matrix_present_flag\n                    scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n                    for (i = 0; i < scalingListCount; i++) {\n                        if (readBoolean()) {\n                            // seq_scaling_list_present_flag[ i ]\n                            i < 6 ? skipScalingList(16) : skipScalingList(64);\n                        }\n                    }\n                }\n            }\n            skipUEG(); // log2_max_frame_num_minus4\n            var picOrderCntType = readUEG();\n            if (picOrderCntType === 0) {\n                readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n            } else if (picOrderCntType === 1) {\n                skipBits(1); // delta_pic_order_always_zero_flag\n                skipEG(); // offset_for_non_ref_pic\n                skipEG(); // offset_for_top_to_bottom_field\n                numRefFramesInPicOrderCntCycle = readUEG();\n                for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n                    skipEG(); // offset_for_ref_frame[ i ]\n                }\n            }\n            var refFrames = readUEG(); // max_num_ref_frames\n            skipBits(1); // gaps_in_frame_num_value_allowed_flag\n            picWidthInMbsMinus1 = readUEG();\n            picHeightInMapUnitsMinus1 = readUEG();\n            frameMbsOnlyFlag = readBits(1);\n            if (frameMbsOnlyFlag === 0) {\n                skipBits(1); // mb_adaptive_frame_field_flag\n            }\n            skipBits(1); // direct_8x8_inference_flag\n            if (readBoolean()) {\n                // frame_cropping_flag\n                frameCropLeftOffset = readUEG();\n                frameCropRightOffset = readUEG();\n                frameCropTopOffset = readUEG();\n                frameCropBottomOffset = readUEG();\n            }\n            var frameRate = {\n                fps: 0,\n                fpsFixed: true,\n                fpsNum: 0,\n                fpsDen: 0\n            };\n            var pixelRatio = [1, 1];\n            if (readBoolean()) {\n                // vui_parameters_present_flag\n                if (readBoolean()) {\n                    // aspect_ratio_info_present_flag\n                    var aspectRatioIdc = readUByte();\n                    switch (aspectRatioIdc) {\n                        case 1:\n                            pixelRatio = [1, 1];\n                            break;\n                        case 2:\n                            pixelRatio = [12, 11];\n                            break;\n                        case 3:\n                            pixelRatio = [10, 11];\n                            break;\n                        case 4:\n                            pixelRatio = [16, 11];\n                            break;\n                        case 5:\n                            pixelRatio = [40, 33];\n                            break;\n                        case 6:\n                            pixelRatio = [24, 11];\n                            break;\n                        case 7:\n                            pixelRatio = [20, 11];\n                            break;\n                        case 8:\n                            pixelRatio = [32, 11];\n                            break;\n                        case 9:\n                            pixelRatio = [80, 33];\n                            break;\n                        case 10:\n                            pixelRatio = [18, 11];\n                            break;\n                        case 11:\n                            pixelRatio = [15, 11];\n                            break;\n                        case 12:\n                            pixelRatio = [64, 33];\n                            break;\n                        case 13:\n                            pixelRatio = [160, 99];\n                            break;\n                        case 14:\n                            pixelRatio = [4, 3];\n                            break;\n                        case 15:\n                            pixelRatio = [3, 2];\n                            break;\n                        case 16:\n                            pixelRatio = [2, 1];\n                            break;\n                        case 255:\n                            {\n                                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                                break;\n                            }\n                    }\n                }\n                if (readBoolean()) {\n                    // overscan_info_present_flag\n                    readBoolean(); // overscan_appropriate_flag\n                }\n                if (readBoolean()) {\n                    // video_signal_type_present_flag\n                    readBits(4); // video_format & video_full_range_flag\n                    if (readBoolean()) {\n                        // colour_description_present_flag\n                        readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n                    }\n                }\n                if (readBoolean()) {\n                    // chroma_loc_info_present_flag\n                    readUEG(); // chroma_sample_loc_type_top_field\n                    readUEG(); // chroma_sample_loc_type_bottom_field\n                }\n\n                if (readBoolean()) {\n                    // timing_info_present_flag\n                    var numUnitInTick = readBits(32);\n                    frameRate.fpsNum = readBits(32);\n                    frameRate.fixed = this.readBoolean();\n                    frameRate.fpsDen = numUnitInTick * 2;\n                    frameRate.fps = frameRate.fpsNum / frameRate.fpsDen;\n                }\n                var cropUnitX = 0,\n                    cropUnitY = 0;\n                if (chromaFormatIdc === 0) {\n                    cropUnitX = 1;\n                    cropUnitX = 2 - frameMbsOnlyFlag;\n                } else {\n                    var subWc = chromaFormatIdc === 3 ? 1 : 2;\n                    var subHc = chromaFormatIdc === 1 ? 2 : 1;\n                    cropUnitX = subWc;\n                    cropUnitY = subHc * (2 - frameMbsOnlyFlag);\n                }\n\n                codecWidth = (picWidthInMbsMinus1 + 1) * 16;\n                codecHeight = (2 - frameMbsOnlyFlag) * ((picHeightInMapUnitsMinus1 + 1) * 16);\n\n                codecWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;\n                codecHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;\n\n                var pixelScale = pixelRatio[0] === 1 || pixelRatio[1] === 1 ? 1 : pixelRatio[0] / pixelRatio[1];\n\n                presentWidth = pixelScale * codecWidth;\n            }\n            return {\n                profileIdc: profileIdc,\n                levelIdc: levelIdc,\n                refFrames: refFrames,\n                chromaFormat: chromaFormat,\n                bitDepth: bitDepthLuma,\n                frameRate: frameRate,\n                codecSize: {\n                    width: codecWidth,\n                    height: codecHeight\n                },\n                presentSize: {\n                    width: presentWidth,\n                    height: codecHeight\n                },\n                width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n                height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n                pixelRatio: pixelRatio\n            };\n        }\n    }, {\n        key: 'readSliceType',\n        value: function readSliceType() {\n            // skip NALu type\n            this.readUByte();\n            // discard first_mb_in_slice\n            this.readUEG();\n            // return slice_type\n            return this.readUEG();\n        }\n    }]);\n\n    return ExpGolomb;\n}();\n\nexports.default = ExpGolomb;\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/ExpGolomb.js?");

/***/ }),

/***/ "./src/utils/Log.js":
/*!**************************!*\
  !*** ./src/utils/Log.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Logger = function () {\n    function Logger() {\n        _classCallCheck(this, Logger);\n    }\n\n    _createClass(Logger, null, [{\n        key: \"log\",\n        value: function log() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            window.console.log.apply(window, args);\n        }\n    }, {\n        key: \"info\",\n        value: function info() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            window.console.info.apply(window, args);\n        }\n    }, {\n        key: \"error\",\n        value: function error() {\n            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n            }\n\n            window.console.error.apply(window, args);\n        }\n    }, {\n        key: \"warn\",\n        value: function warn() {\n            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                args[_key4] = arguments[_key4];\n            }\n\n            window.console.warn.apply(window, args);\n        }\n    }]);\n\n    return Logger;\n}();\n\nexports.default = Logger;\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/Log.js?");

/***/ }),

/***/ "./src/utils/UTF8.js":
/*!***************************!*\
  !*** ./src/utils/UTF8.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable */\nvar UTF8 = function () {\n    function UTF8() {\n        _classCallCheck(this, UTF8);\n    }\n\n    _createClass(UTF8, null, [{\n        key: 'decode',\n        value: function decode(uint8array) {\n            var out = [];\n            var input = uint8array;\n            var i = 0;\n            var length = uint8array.length;\n\n            while (i < length) {\n                if (input[i] < 0x80) {\n                    out.push(String.fromCharCode(input[i]));\n                    ++i;\n                    continue;\n                } else if (input[i] < 0xC0) {\n                    // fallthrough\n                } else if (input[i] < 0xE0) {\n                    if (UTF8._checkContinuation(input, i, 1)) {\n                        var ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n                        if (ucs4 >= 0x80) {\n                            out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                            i += 2;\n                            continue;\n                        }\n                    }\n                } else if (input[i] < 0xF0) {\n                    if (UTF8._checkContinuation(input, i, 2)) {\n                        var _ucs = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n                        if (_ucs >= 0x800 && (_ucs & 0xF800) !== 0xD800) {\n                            out.push(String.fromCharCode(_ucs & 0xFFFF));\n                            i += 3;\n                            continue;\n                        }\n                    }\n                } else if (input[i] < 0xF8) {\n                    if (UTF8._checkContinuation(input, i, 3)) {\n                        var _ucs2 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n                        if (_ucs2 > 0x10000 && _ucs2 < 0x110000) {\n                            _ucs2 -= 0x10000;\n                            out.push(String.fromCharCode(_ucs2 >>> 10 | 0xD800));\n                            out.push(String.fromCharCode(_ucs2 & 0x3FF | 0xDC00));\n                            i += 4;\n                            continue;\n                        }\n                    }\n                }\n                out.push(String.fromCharCode(0xFFFD));\n                ++i;\n            }\n\n            return out.join('');\n        }\n    }, {\n        key: '_checkContinuation',\n        value: function _checkContinuation(uint8array, start, checkLength) {\n            var array = uint8array;\n            if (start + checkLength < array.length) {\n                while (checkLength--) {\n                    if ((array[++start] & 0xC0) !== 0x80) return false;\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }]);\n\n    return UTF8;\n}();\n\nexports.default = UTF8;\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/UTF8.js?");

/***/ }),

/***/ "./src/utils/funcUtils.js":
/*!********************************!*\
  !*** ./src/utils/funcUtils.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.debounce = debounce;\nfunction debounce(func, wait, immediate) {\n    var timeout, result;\n\n    var debounced = function debounced(args) {\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        if (immediate) {\n            var callNow = !timeout;\n            timeout = setTimeout(func, wait);\n            if (callNow) {\n                result = func();\n            }\n        } else {\n            timeout = setTimeout(func, wait);\n        }\n\n        return result;\n    };\n\n    debounced.cancel = function () {\n        clearTimeout(timeout);\n        timeout = null;\n    };\n\n    return debounced;\n}\n\nvar cacheWrapper = exports.cacheWrapper = function cacheWrapper(fn) {\n\n    var cache = {};\n    return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        var key = args.reduce(function (pre, cur) {\n            return pre + '_' + cur;\n        }, '');\n        var result = fn.apply(undefined, args);\n        if (cache[key] !== undefined) {\n            return cache[key];\n        } else {\n            cache[key] = result;\n            return result;\n        }\n    };\n};\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/funcUtils.js?");

/***/ }),

/***/ "./src/utils/sniffer.js":
/*!******************************!*\
  !*** ./src/utils/sniffer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar le = function () {\n    var buf = new ArrayBuffer(2);\n    new DataView(buf).setInt16(0, 256, true); // little-endian write\n    return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\nvar sniffer = {\n    get device() {\n        var r = sniffer.os;\n        return r.isPc ? 'pc' : r.isTablet ? 'tablet' : 'mobile';\n    },\n    get browser() {\n        var ua = navigator.userAgent.toLowerCase();\n        var reg = {\n            ie: /rv:([\\d.]+)\\) like gecko/,\n            firfox: /firefox\\/([\\d.]+)/,\n            chrome: /chrome\\/([\\d.]+)/,\n            opera: /opera.([\\d.]+)/,\n            safari: /version\\/([\\d.]+).*safari/\n        };\n        return [].concat(Object.keys(reg).filter(function (key) {\n            return reg[key].test(ua);\n        }))[0];\n    },\n    get os() {\n        var ua = navigator.userAgent,\n            isWindowsPhone = /(?:Windows Phone)/.test(ua),\n            isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone,\n            isAndroid = /(?:Android)/.test(ua),\n            isFireFox = /(?:Firefox)/.test(ua),\n            isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua),\n            isPhone = /(?:iPhone)/.test(ua) && !isTablet,\n            isPc = !isPhone && !isAndroid && !isSymbian;\n        return {\n            isTablet: isTablet,\n            isPhone: isPhone,\n            isAndroid: isAndroid,\n            isPc: isPc,\n            isSymbian: isSymbian,\n            isWindowsPhone: isWindowsPhone,\n            isFireFox: isFireFox\n        };\n    },\n    get isLe() {\n        return le;\n    }\n};\n\nexports.default = sniffer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/utils/sniffer.js?");

/***/ }),

/***/ "./src/write/Buffer.js":
/*!*****************************!*\
  !*** ./src/write/Buffer.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _concatTypedArray = __webpack_require__(/*! concat-typed-array */ \"./node_modules/concat-typed-array/lib/index.js\");\n\nvar _concatTypedArray2 = _interopRequireDefault(_concatTypedArray);\n\nvar _Log = __webpack_require__(/*! ../utils/Log */ \"./src/utils/Log.js\");\n\nvar _Log2 = _interopRequireDefault(_Log);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = function () {\n    function Buffer(buffer) {\n        _classCallCheck(this, Buffer);\n\n        this.buffer = buffer || new Uint8Array(0);\n    }\n\n    _createClass(Buffer, [{\n        key: 'write',\n        value: function write() {\n            var _this = this;\n\n            for (var _len = arguments.length, buffer = Array(_len), _key = 0; _key < _len; _key++) {\n                buffer[_key] = arguments[_key];\n            }\n\n            buffer.forEach(function (item) {\n                if (item) {\n                    _this.buffer = (0, _concatTypedArray2.default)(Uint8Array, _this.buffer, item);\n                } else {\n                    _Log2.default.error(item);\n                }\n            });\n        }\n    }], [{\n        key: 'writeUint32',\n        value: function writeUint32(value) {\n            return new Uint8Array([value >> 24, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff]);\n        }\n    }, {\n        key: 'readAsInt',\n        value: function readAsInt(arr) {\n            var temp = '';\n            function padStart4Hex(hexNum) {\n                var hexStr = hexNum.toString(16);\n                return hexStr.padStart(2, '0');\n            }\n            arr.forEach(function (num) {\n                temp += padStart4Hex(num);\n            });\n            return parseInt(temp, 16);\n        }\n    }]);\n\n    return Buffer;\n}();\n\nexports.default = Buffer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/write/Buffer.js?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack://xgplayer-flv/multi_./src/index.js?");

/***/ }),

/***/ "xgplayer":
/*!***************************!*\
  !*** external "xgplayer" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_xgplayer__;\n\n//# sourceURL=webpack://xgplayer-flv/external_%22xgplayer%22?");

/***/ })

/******/ });
});